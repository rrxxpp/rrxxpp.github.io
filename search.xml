<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android ImageView scaleType 扩展，类似centerCrop，但从顶部开始显示。</title>
    <url>/2021/11/12/android-image-topcrop/</url>
    <content><![CDATA[<h1 id="项目内遇到图片适配的功能，全屏展示图片，尽可能的显示完整内容，开始考虑使用centerCrop与fitStart，查询之后发现："><a href="#项目内遇到图片适配的功能，全屏展示图片，尽可能的显示完整内容，开始考虑使用centerCrop与fitStart，查询之后发现：" class="headerlink" title="项目内遇到图片适配的功能，全屏展示图片，尽可能的显示完整内容，开始考虑使用centerCrop与fitStart，查询之后发现："></a>项目内遇到图片适配的功能，全屏展示图片，尽可能的显示完整内容，开始考虑使用centerCrop与fitStart，查询之后发现：</h1><h3 id="1、centerCrop从中间开始展示，也就是如果长宽与空间尺寸不一致，图片的长宽都可能被裁切，不满足使用。"><a href="#1、centerCrop从中间开始展示，也就是如果长宽与空间尺寸不一致，图片的长宽都可能被裁切，不满足使用。" class="headerlink" title="1、centerCrop从中间开始展示，也就是如果长宽与空间尺寸不一致，图片的长宽都可能被裁切，不满足使用。"></a><strong>1、centerCrop从中间开始展示，也就是如果长宽与空间尺寸不一致，图片的长宽都可能被裁切，不满足使用。</strong></h3><blockquote>
<p>测试CENTER_CROP属性</p>
<p>将图片放在ImageView的中心点，然后对图片进行等比例缩放</p>
<p>官方文档描述：<br>Scale the image uniformly (maintain the image’s aspect ratio) so that<br>both dimensions (width and height) of the image will be equal to or larger<br>than the corresponding dimension of the view (minus padding).<br>这段文字值得好好体会一下。<br>简而言之：<br>等比例缩放图片使得图片的宽和高均不小于控件对应的宽高</p>
<p>1.1 若图片宽和高均小于ImageView控件的宽高，则等比例放大图片，直至铺满ImageView.<br>      当然这种情况下的等比例放大，就可能导致图片X或Y方向的图片显示不全<br>1.2 若图片宽或高小于ImageView控件的宽或高,则将图片等比例放大直到铺满ImageView<br>      比如ImageView为750<em>750,图片为600</em>800,所以会等比例放大图片，直至图片宽度变为<br>      750.但是这样会造成图片的高度大于了ImageView的高，所以图片的垂直方向显示不全，会被剪裁<br>1.3 如图片宽和高均大于ImageView控件的宽和高<br>      此时等比例缩小图片，当图片的宽高中任意一值等于控件对应的宽高时停止缩小图片。<br>      在这种情况下就很可能造成：图片显示不完整</p>
<p>所以CENTER_CROP属性的显著特点:<br>图片会铺满整个ImageView，但图片可能显示不完整<br>————————————————<br>版权声明：本文为CSDN博主「谷哥的小弟」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/lfdfhl/article/details/52144250">https://blog.csdn.net/lfdfhl/article/details/52144250</a></p>
</blockquote>
<h3 id="2、fitStart-属性完整显示图片，导致如果高度与宽度不一致，可能高度填充，宽度有白边。"><a href="#2、fitStart-属性完整显示图片，导致如果高度与宽度不一致，可能高度填充，宽度有白边。" class="headerlink" title="2、fitStart 属性完整显示图片，导致如果高度与宽度不一致，可能高度填充，宽度有白边。"></a><strong>2、fitStart 属性完整显示图片，导致如果高度与宽度不一致，可能高度填充，宽度有白边。</strong></h3><blockquote>
<p>测试FIT_CENTER属性</p>
<p>将图片放在ImageView的中心点，然后对图片进行等比例缩放</p>
<p>官方文档：<br>Scale the image using CENTER.<br>CENTER:<br>Compute a scale that will maintain the original src aspect ratio,<br>but will also ensure that src fits entirely inside dst.<br>At least one axis (X or Y) will fit exactly. The result is centered inside dst.</p>
<p>在理解了CENTER_CROP和CENTER_INSIDE之后再看FIT_CENTER就会好理解一些</p>
<p>将图片放在ImageView的中心点，对图片进行等比例缩放从而完整地显示图片</p>
<p>1.1 若图片宽和高均小于ImageView控件的宽高，则等比例放大图片<br>      直到图片的宽高中任意一值等于控件的宽或者高<br>      此情况下，图片的上下或者左右可见ImageView的背景色</p>
<p>1.2 若图片宽和高均大于ImageView控件的宽和高，则等比例缩小图片<br>      直到图片的宽高中任意一值等于控件的宽或者高<br>      所以，这也很容易导致图片的上下或者左右可见ImageView的背景色</p>
<p>1.3 若图片宽或高大于ImageView控件的宽或高<br>      这时候是该执行放大呢？还是缩小呢？<br>      其实，此时是有一个原则的：完整地显示图片。<br>      就像文档中所说：ensure that src fits entirely inside dst<br>      所以，此时会对图片进行缩放，直到图片的宽高均不大于控件的宽高</p>
<p>所以，在使用FIT_CENTER时可以完整地显示图片，而且它有一个显著的特点：<br>它使得图片的宽高中至少有一个值恰好等于控件的宽或者高。<br>这一点也是它和CENTER_INSIDE属性的主要区别</p>
<p>————————————————<br>版权声明：本文为CSDN博主「谷哥的小弟」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/lfdfhl/article/details/52144250">https://blog.csdn.net/lfdfhl/article/details/52144250</a></p>
</blockquote>
<p><strong>综合考虑，决定使用宽度填充，高度等比例缩放，多余部分填充，UI图片下方保留安全区域，与centerCrop类似，只是图片从顶部保留，自定义View如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TopCropImageView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">androidx</span>.<span class="hljs-title">appcompat</span>.<span class="hljs-title">widget</span>.<span class="hljs-title">AppCompatImageView</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TopCropImageView</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(context);<br>        setScaleType(ScaleType.MATRIX);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TopCropImageView</span><span class="hljs-params">(Context context, <span class="hljs-meta">@Nullable</span> AttributeSet attrs)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(context, attrs);<br>        setScaleType(ScaleType.MATRIX);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TopCropImageView</span><span class="hljs-params">(Context context, <span class="hljs-meta">@Nullable</span> AttributeSet attrs, <span class="hljs-keyword">int</span> defStyleAttr)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(context, attrs, defStyleAttr);<br>        setScaleType(ScaleType.MATRIX);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">setFrame</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> t, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (getDrawable() == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.setFrame(frameLeft, frameTop, frameRight, frameBottom);<br>        &#125;<br>        <span class="hljs-comment">//frame 宽度</span><br>        <span class="hljs-keyword">float</span> frameWidth = frameRight - frameLeft;<br>        <span class="hljs-comment">//图片宽度</span><br>        <span class="hljs-keyword">float</span> originalImageWidth = (<span class="hljs-keyword">float</span>)getDrawable().getIntrinsicWidth();<br>        <span class="hljs-comment">//缩放比例</span><br>        <span class="hljs-keyword">float</span> usedScaleFactor = frameWidth/originalImageWidth;<br><br>        Matrix matrix = getImageMatrix();<br>        matrix.setScale(usedScaleFactor, usedScaleFactor, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>); <br>        setImageMatrix(matrix);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.setFrame(frameLeft, frameTop, frameRight, frameBottom);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>之前在setFrame内使用getWidth（），发现部分请款返回数值为0的问题，改为使用right-left。</p>
<p>其余情况也一致，bottomCenter，left 等等，都可通过Matrix矩阵（Scale：缩放、 Skew：错切、 Rotate：旋转、Translate：平移）实现。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>屏幕尺寸大全</title>
    <url>/2021/11/12/android-screen/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="left">设备名称</th>
<th align="left">操作系统</th>
<th align="left">尺寸 in</th>
<th align="left">PPI</th>
<th align="left">纵横比</th>
<th align="left">宽 x 高 dp</th>
<th align="left">宽 x 高 px</th>
<th align="left">密度 dpi</th>
</tr>
</thead>
<tbody><tr>
<td align="left">iPhone 12 Pro Max</td>
<td align="left">iOS</td>
<td align="left">6.7</td>
<td align="left">458</td>
<td align="left">19 : 9</td>
<td align="left">428 x 926</td>
<td align="left">1284 x 2778</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">iPhone 12 Pro</td>
<td align="left">iOS</td>
<td align="left">6.1</td>
<td align="left">460</td>
<td align="left">19 : 9</td>
<td align="left">390 x 844</td>
<td align="left">1170 x 2532</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">iPhone 12 Mini</td>
<td align="left">iOS</td>
<td align="left">5.4</td>
<td align="left">476</td>
<td align="left">19 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">iPhone 11 Pro</td>
<td align="left">iOS</td>
<td align="left">5.8</td>
<td align="left">458</td>
<td align="left">19 : 9</td>
<td align="left">375 x 812</td>
<td align="left">1125 x 2436</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">iPhone 11 Pro Max</td>
<td align="left">iOS</td>
<td align="left">6.5</td>
<td align="left">458</td>
<td align="left">19 : 9</td>
<td align="left">414 x 896</td>
<td align="left">1242 x 2688</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">iPhone 11 （11，XR）</td>
<td align="left">iOS</td>
<td align="left">6.1</td>
<td align="left">326</td>
<td align="left">19 : 9</td>
<td align="left">414 x 896</td>
<td align="left">828 x 1792</td>
<td align="left">2.0 xhdpi</td>
</tr>
<tr>
<td align="left">iPhone XS Max</td>
<td align="left">iOS</td>
<td align="left">6.5</td>
<td align="left">458</td>
<td align="left">19 : 9</td>
<td align="left">414 x 896</td>
<td align="left">1242 x 2688</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">iPhone X (X,XS)</td>
<td align="left">iOS</td>
<td align="left">5.8</td>
<td align="left">458</td>
<td align="left">19 : 9</td>
<td align="left">375 x 812</td>
<td align="left">1125 x 2436</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">iPhone 8+ (8+, 7+, 6S+, 6+)</td>
<td align="left">iOS</td>
<td align="left">5.5</td>
<td align="left">401</td>
<td align="left">16 : 9</td>
<td align="left">414 x 736</td>
<td align="left">1242 x 2208</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">iPhone 8 (8, 7, 6S, 6)</td>
<td align="left">iOS</td>
<td align="left">4.7</td>
<td align="left">326</td>
<td align="left">16 : 9</td>
<td align="left">375 x 667</td>
<td align="left">750 x 1334</td>
<td align="left">2.0 xhdpi</td>
</tr>
<tr>
<td align="left">iPhone SE（SE, 5S, 5C）</td>
<td align="left">iOS</td>
<td align="left">4.0</td>
<td align="left">326</td>
<td align="left">16 : 9</td>
<td align="left">320 x 568</td>
<td align="left">640 x 1136</td>
<td align="left">2.0 xhdpi</td>
</tr>
<tr>
<td align="left">Android One</td>
<td align="left">Android</td>
<td align="left">4.5</td>
<td align="left">218</td>
<td align="left">16 : 9</td>
<td align="left">320 x 569</td>
<td align="left">480 x 854</td>
<td align="left">1.5 hdpi</td>
</tr>
<tr>
<td align="left">Google Pixel 3 (3,Lite)</td>
<td align="left">Android</td>
<td align="left">5.5</td>
<td align="left">439</td>
<td align="left">2:1</td>
<td align="left">360 x 720</td>
<td align="left">1080 x 2160</td>
<td align="left">3 xxhdpi</td>
</tr>
<tr>
<td align="left">Google Pixel</td>
<td align="left">Android</td>
<td align="left">5.0</td>
<td align="left">441</td>
<td align="left">16 : 9</td>
<td align="left">411 x 731</td>
<td align="left">1080 x 1920</td>
<td align="left">2.6 xxhdpi</td>
</tr>
<tr>
<td align="left">Google Pixel XL</td>
<td align="left">Android</td>
<td align="left">5.5</td>
<td align="left">534</td>
<td align="left">16 : 9</td>
<td align="left">411 x 731</td>
<td align="left">1440 x 2560</td>
<td align="left">3.5 xxxhdpi</td>
</tr>
<tr>
<td align="left">Moto Z3</td>
<td align="left">Android</td>
<td align="left">6.01</td>
<td align="left">402</td>
<td align="left">2:1</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2160</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Moto G7 PLUS</td>
<td align="left">Android</td>
<td align="left">6.24</td>
<td align="left">407</td>
<td align="left">-</td>
<td align="left">360 x 757</td>
<td align="left">1080 x 2270</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Moto 青柚1s</td>
<td align="left">Android</td>
<td align="left">5.7</td>
<td align="left">424</td>
<td align="left">2:1</td>
<td align="left">360 x 720</td>
<td align="left">1080 x 2160</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Moto P30 Note</td>
<td align="left">Android</td>
<td align="left">6.2</td>
<td align="left">402</td>
<td align="left">-</td>
<td align="left">360 x 749</td>
<td align="left">1080 x 2246</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Moto X</td>
<td align="left">Android</td>
<td align="left">4.7</td>
<td align="left">312</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">720 x 1280</td>
<td align="left">2.0 xhdpi</td>
</tr>
<tr>
<td align="left">Moto X 二代</td>
<td align="left">Android</td>
<td align="left">5.2</td>
<td align="left">424</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">1080 x 1920</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Nexus 5</td>
<td align="left">Android</td>
<td align="left">5.0</td>
<td align="left">445</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">1080 x 1920</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Nexus 5X</td>
<td align="left">Android</td>
<td align="left">5.2</td>
<td align="left">565</td>
<td align="left">16 : 9</td>
<td align="left">411 x 731</td>
<td align="left">1080 x 1920</td>
<td align="left">2.6 xxhdpi</td>
</tr>
<tr>
<td align="left">Nexus 6</td>
<td align="left">Android</td>
<td align="left">6.0</td>
<td align="left">493</td>
<td align="left">16 : 9</td>
<td align="left">411 x 731</td>
<td align="left">1440 x 2560</td>
<td align="left">3.5 xxxhdpi</td>
</tr>
<tr>
<td align="left">Nexus 6P</td>
<td align="left">Android</td>
<td align="left">5.7</td>
<td align="left">518</td>
<td align="left">16 : 9</td>
<td align="left">411 x 731</td>
<td align="left">1440 x 2560</td>
<td align="left">3.5 xxxhdpi</td>
</tr>
<tr>
<td align="left">Samsung Galaxy A70（A70，A80）</td>
<td align="left">Android</td>
<td align="left">6.7</td>
<td align="left">393</td>
<td align="left">20 : 9</td>
<td align="left">360 x 800</td>
<td align="left">1080 x 2400</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Samsung Galaxy A60</td>
<td align="left">Android</td>
<td align="left">6.3</td>
<td align="left">409</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Samsung Galaxy A40s</td>
<td align="left">Android</td>
<td align="left">6.4</td>
<td align="left">268</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">720 x 1560</td>
<td align="left">2.0 xhdpi</td>
</tr>
<tr>
<td align="left">Samsung Galaxy A8s</td>
<td align="left">Android</td>
<td align="left">6.4</td>
<td align="left">403</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Samsung Galaxy S10e</td>
<td align="left">Android</td>
<td align="left">5.8</td>
<td align="left">435</td>
<td align="left">19 : 9</td>
<td align="left">360 x 760</td>
<td align="left">1080 x 2280</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Samsung Galaxy S10+</td>
<td align="left">Android</td>
<td align="left">6.4</td>
<td align="left">526</td>
<td align="left">19 : 9</td>
<td align="left">360 x 760</td>
<td align="left">1440 x 3040</td>
<td align="left">4.0 xxxhdpi</td>
</tr>
<tr>
<td align="left">Samsung Galaxy S10</td>
<td align="left">Android</td>
<td align="left">6.1</td>
<td align="left">551</td>
<td align="left">19 : 9</td>
<td align="left">360 x 760</td>
<td align="left">1440 x 3040</td>
<td align="left">4.0 xxxhdpi</td>
</tr>
<tr>
<td align="left">Samsung Galaxy S9</td>
<td align="left">Android</td>
<td align="left">5.8</td>
<td align="left">568</td>
<td align="left">18.5 : 9</td>
<td align="left">360 x 740</td>
<td align="left">1440 x 2960</td>
<td align="left">4.0 xxxhdpi</td>
</tr>
<tr>
<td align="left">Samsung Galaxy S9+</td>
<td align="left">Android</td>
<td align="left">6.2</td>
<td align="left">531</td>
<td align="left">18.5 : 9</td>
<td align="left">360 x 740</td>
<td align="left">1440 x 2960</td>
<td align="left">4.0 xxxhdpi</td>
</tr>
<tr>
<td align="left">Samsung Galaxy S8</td>
<td align="left">Android</td>
<td align="left">5.8</td>
<td align="left">570</td>
<td align="left">18.5 : 9</td>
<td align="left">360 x 740</td>
<td align="left">1440 x 2960</td>
<td align="left">4.0 xxxhdpi</td>
</tr>
<tr>
<td align="left">Samsung Galaxy S8+</td>
<td align="left">Android</td>
<td align="left">6.2</td>
<td align="left">529</td>
<td align="left">18.5 : 9</td>
<td align="left">360 x 740</td>
<td align="left">1440 x 2960</td>
<td align="left">4.0 xxxhdpi</td>
</tr>
<tr>
<td align="left">Samsung Galaxy Note10 5G</td>
<td align="left">Android</td>
<td align="left">6.3</td>
<td align="left">534</td>
<td align="left">19 : 9</td>
<td align="left">360 x 760</td>
<td align="left">1440 x 3040</td>
<td align="left">4.0 xxxhdpi</td>
</tr>
<tr>
<td align="left">Samsung Galaxy Note10</td>
<td align="left">Android</td>
<td align="left">6.3</td>
<td align="left">400</td>
<td align="left">19 : 9</td>
<td align="left">360 x 760</td>
<td align="left">1080 x 2280</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Samsung Galaxy Note 9</td>
<td align="left">Android</td>
<td align="left">6.4</td>
<td align="left">514</td>
<td align="left">18.5 : 9</td>
<td align="left">360 x 740</td>
<td align="left">1440 x 2960</td>
<td align="left">4.0 xxxhdpi</td>
</tr>
<tr>
<td align="left">Samsung Galaxy Note 4</td>
<td align="left">Android</td>
<td align="left">5.7</td>
<td align="left">515</td>
<td align="left">16 : 9</td>
<td align="left">480 x 853</td>
<td align="left">1440 x 2560</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Samsung Galaxy Note5</td>
<td align="left">Android</td>
<td align="left">5.7</td>
<td align="left">518</td>
<td align="left">16 : 9</td>
<td align="left">480 x 853</td>
<td align="left">1440 x 2560</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Samsung Galaxy S5</td>
<td align="left">Android</td>
<td align="left">5.1</td>
<td align="left">432</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">1080 x 1920</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Samsung Galaxy S7 (S7, S6, S6 Edge)</td>
<td align="left">Android</td>
<td align="left">5.1</td>
<td align="left">576</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">1440 x 2560</td>
<td align="left">4.0 xxxhdpi</td>
</tr>
<tr>
<td align="left">Samsung Galaxy S7 Edge</td>
<td align="left">Android</td>
<td align="left">5.5</td>
<td align="left">534</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">1440 x 2560</td>
<td align="left">4.0 xxxhdpi</td>
</tr>
<tr>
<td align="left">Smartisan T2</td>
<td align="left">Android</td>
<td align="left">4.95</td>
<td align="left">445</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">1080 x 1920</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Smartisan M1</td>
<td align="left">Android</td>
<td align="left">5.15</td>
<td align="left">428</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">1080 x 1920</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Smartisan M1L</td>
<td align="left">Android</td>
<td align="left">5.7</td>
<td align="left">515</td>
<td align="left">16 : 9</td>
<td align="left">480 x 853</td>
<td align="left">1440 x 2560</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">坚果 R1</td>
<td align="left">Android</td>
<td align="left">6.17</td>
<td align="left">403</td>
<td align="left">-</td>
<td align="left">360 x 640</td>
<td align="left">1080 x 2242</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">坚果 3</td>
<td align="left">Android</td>
<td align="left">5.99</td>
<td align="left">403</td>
<td align="left">2:1</td>
<td align="left">360 x 720</td>
<td align="left">1080 x 2160</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">坚果 Pro2s</td>
<td align="left">Android</td>
<td align="left">6.01</td>
<td align="left">402</td>
<td align="left">2:1</td>
<td align="left">360 x 720</td>
<td align="left">1080 x 2160</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">坚果 Pro2</td>
<td align="left">Android</td>
<td align="left">6.01</td>
<td align="left">403</td>
<td align="left">2:1</td>
<td align="left">360 x 720</td>
<td align="left">1080 x 2160</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">坚果 Pro</td>
<td align="left">Android</td>
<td align="left">5.5</td>
<td align="left">403</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">1080 x 1920</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">OnePlus 7 Pro</td>
<td align="left">Android</td>
<td align="left">6.67</td>
<td align="left">516</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1440 x 3120</td>
<td align="left">4.0 xxxhdpi</td>
</tr>
<tr>
<td align="left">OnePlus 7</td>
<td align="left">Android</td>
<td align="left">6.41</td>
<td align="left">402</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">OnePlus 5</td>
<td align="left">Android</td>
<td align="left">5.5</td>
<td align="left">401</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">1080 x 1920</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">OnePlus 6T</td>
<td align="left">Android</td>
<td align="left">6.41</td>
<td align="left">402</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">OnePlus 3T</td>
<td align="left">Android</td>
<td align="left">5.5</td>
<td align="left">401</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">1080 x 1920</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Oppo R9s (R9s, R11)</td>
<td align="left">Android</td>
<td align="left">5.5</td>
<td align="left">401</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">1080 x 1920</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Oppo R9s Plus (R9s Plus, R11 Plus)</td>
<td align="left">Android</td>
<td align="left">6.0</td>
<td align="left">368</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">1080 x 1920</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Oppo Find X</td>
<td align="left">Android</td>
<td align="left">6.42</td>
<td align="left">401</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Oppo Reno2</td>
<td align="left">Android</td>
<td align="left">6.5</td>
<td align="left">401</td>
<td align="left">-</td>
<td align="left">360 x 800</td>
<td align="left">1080 x 2400</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Oppo Reno</td>
<td align="left">Android</td>
<td align="left">6.4</td>
<td align="left">402</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Oppo Reno 10</td>
<td align="left">Android</td>
<td align="left">6.6</td>
<td align="left">387</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Oppo Reno Z</td>
<td align="left">Android</td>
<td align="left">6.4</td>
<td align="left">402</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Oppo R15x (R15x,R17,R17 Pro)</td>
<td align="left">Android</td>
<td align="left">6.4</td>
<td align="left">402</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Oppo K3</td>
<td align="left">Android</td>
<td align="left">6.5</td>
<td align="left">394</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Oppo A9(A9,A9x)</td>
<td align="left">Android</td>
<td align="left">6.53</td>
<td align="left">394</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Oppo A7</td>
<td align="left">Android</td>
<td align="left">6.2</td>
<td align="left">271</td>
<td align="left">19 : 9</td>
<td align="left">360 x 760</td>
<td align="left">720 x 1520</td>
<td align="left">2.0 xhdpi</td>
</tr>
<tr>
<td align="left">Oppo A7x</td>
<td align="left">Android</td>
<td align="left">6.3</td>
<td align="left">409</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Oppo A5</td>
<td align="left">Android</td>
<td align="left">6.2</td>
<td align="left">271</td>
<td align="left">19 : 9</td>
<td align="left">360 x 760</td>
<td align="left">720 x 1520</td>
<td align="left">2.0 xhdpi</td>
</tr>
<tr>
<td align="left">Oppo A57</td>
<td align="left">Android</td>
<td align="left">5.2</td>
<td align="left">282</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">720 x 1280</td>
<td align="left">2.0 xhdpi</td>
</tr>
<tr>
<td align="left">Oppo A59s</td>
<td align="left">Android</td>
<td align="left">5.5</td>
<td align="left">267</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">720 x 1280</td>
<td align="left">2.0 xhdpi</td>
</tr>
<tr>
<td align="left">Oppo A37</td>
<td align="left">Android</td>
<td align="left">5.0</td>
<td align="left">293</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">720 x 1280</td>
<td align="left">2.0 xhdpi</td>
</tr>
<tr>
<td align="left">小米10（至尊纪念版）</td>
<td align="left">Android</td>
<td align="left">6.67</td>
<td align="left">386</td>
<td align="left">13 : 6</td>
<td align="left">-</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">小米10 Pro</td>
<td align="left">Android</td>
<td align="left">6.67</td>
<td align="left">395</td>
<td align="left">20 : 9</td>
<td align="left">-</td>
<td align="left">1080 x 2400</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">小米CC9</td>
<td align="left">Android</td>
<td align="left">6.39</td>
<td align="left">403</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">小米CC9e</td>
<td align="left">Android</td>
<td align="left">6.088</td>
<td align="left">282</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">720 x 1560</td>
<td align="left">2.0 xhdpi</td>
</tr>
<tr>
<td align="left">小米9 (9,9Pro 5G)</td>
<td align="left">Android</td>
<td align="left">6.39</td>
<td align="left">403</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">小米MIX Alpha 5G</td>
<td align="left">Android</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">- -</td>
</tr>
<tr>
<td align="left">小米MIX3</td>
<td align="left">Android</td>
<td align="left">6.39</td>
<td align="left">403</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">小米MIX2 (MIX2,MIX2s)</td>
<td align="left">Android</td>
<td align="left">5.99</td>
<td align="left">403</td>
<td align="left">2:1</td>
<td align="left">360 x 720</td>
<td align="left">1080 x 2160</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">小米MIX</td>
<td align="left">Android</td>
<td align="left">6.4</td>
<td align="left">362</td>
<td align="left">-</td>
<td align="left">360 x 680</td>
<td align="left">1080 x 2040</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">小米Note 3</td>
<td align="left">Android</td>
<td align="left">5.5</td>
<td align="left">403</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">1080 x 1920</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">小米Note 2</td>
<td align="left">Android</td>
<td align="left">5.7</td>
<td align="left">386</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">1080 x 1920</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">小米6</td>
<td align="left">Android</td>
<td align="left">5.15</td>
<td align="left">428</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">1080 x 1920</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">小米5s</td>
<td align="left">Android</td>
<td align="left">5.15</td>
<td align="left">428</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">1080 x 1920</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">小米5s Plus</td>
<td align="left">Android</td>
<td align="left">5.7</td>
<td align="left">386</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">1080 x 1920</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">小米Max</td>
<td align="left">Android</td>
<td align="left">6.44</td>
<td align="left">342</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">1080 x 1920</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">红米K20 (K20,K20 Pro,K20 Pro尊享)</td>
<td align="left">Android</td>
<td align="left">6.39</td>
<td align="left">403</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">红米Note 7 (7,7 Pro,8,8 Pro)</td>
<td align="left">Android</td>
<td align="left">6.3</td>
<td align="left">409</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">红米Note 4 (4, Note 4X)</td>
<td align="left">Android</td>
<td align="left">5.5</td>
<td align="left">403</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">1080 x 1920</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">红米 4 (4, 4X)</td>
<td align="left">Android</td>
<td align="left">5.0</td>
<td align="left">296</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">720 x 1280</td>
<td align="left">2.0 xhdpi</td>
</tr>
<tr>
<td align="left">NEX双屏版</td>
<td align="left">Android</td>
<td align="left">6.39/5.49</td>
<td align="left">404</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Vivo Y7s</td>
<td align="left">Android</td>
<td align="left">6.38</td>
<td align="left">404</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Vivo Y3</td>
<td align="left">Android</td>
<td align="left">6.35</td>
<td align="left">268</td>
<td align="left">-</td>
<td align="left">360 x 772</td>
<td align="left">720 x 1544</td>
<td align="left">2.0 xhdpi</td>
</tr>
<tr>
<td align="left">Vivo Y91(Y91,Y93,Y93s)</td>
<td align="left">Android</td>
<td align="left">6.2</td>
<td align="left">270</td>
<td align="left">19 : 9</td>
<td align="left">360 x 760</td>
<td align="left">720 x 1520</td>
<td align="left">2.0 xhdpi</td>
</tr>
<tr>
<td align="left">Vivo U1</td>
<td align="left">Android</td>
<td align="left">6.2</td>
<td align="left">270</td>
<td align="left">19 : 9</td>
<td align="left">360 x 760</td>
<td align="left">720 x 1520</td>
<td align="left">2.0 xhdpi</td>
</tr>
<tr>
<td align="left">Vivo S1 Pro</td>
<td align="left">Android</td>
<td align="left">6.39</td>
<td align="left">394</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Vivo S1</td>
<td align="left">Android</td>
<td align="left">6.53</td>
<td align="left">394</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Vivo X27 Pro</td>
<td align="left">Android</td>
<td align="left">6.7</td>
<td align="left">401</td>
<td align="left">-</td>
<td align="left">360 x 820</td>
<td align="left">1080 x 2460</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Vivo X27</td>
<td align="left">Android</td>
<td align="left">6.39</td>
<td align="left">394</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Vivo Z5x</td>
<td align="left">Android</td>
<td align="left">6.53</td>
<td align="left">386</td>
<td align="left">19 : 9</td>
<td align="left">360 x 760</td>
<td align="left">1080 x 2280</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Vivo Z5</td>
<td align="left">Android</td>
<td align="left">6.38</td>
<td align="left">404</td>
<td align="left">19 : 9</td>
<td align="left">360 x 760</td>
<td align="left">1080 x 2280</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Vivo Z3</td>
<td align="left">Android</td>
<td align="left">6.3</td>
<td align="left">403</td>
<td align="left">19 : 9</td>
<td align="left">360 x 760</td>
<td align="left">1080 x 2280</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Vivo iQOO Neo</td>
<td align="left">Android</td>
<td align="left">6.38</td>
<td align="left">403</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Vivo iQOO</td>
<td align="left">Android</td>
<td align="left">6.41</td>
<td align="left">402</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Vivo X9 (X9, X9s)</td>
<td align="left">Android</td>
<td align="left">5.5</td>
<td align="left">401</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">1080 x 1920</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Vivo X9 Plus (X9 Plus, X9s Plus)</td>
<td align="left">Android</td>
<td align="left">5.88</td>
<td align="left">375</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">1080 x 1920</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Huawei P40 Pro+</td>
<td align="left">Android</td>
<td align="left">6.58</td>
<td align="left">441</td>
<td align="left">11 : 5</td>
<td align="left">-</td>
<td align="left">1200 x 2640</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Huawei P40 Pro</td>
<td align="left">Android</td>
<td align="left">6.58</td>
<td align="left">441</td>
<td align="left">11 : 5</td>
<td align="left">-</td>
<td align="left">1200 x 2640</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">HUAWEI nova 5i</td>
<td align="left">Android</td>
<td align="left">6.4</td>
<td align="left">398</td>
<td align="left">-</td>
<td align="left">360 x 770</td>
<td align="left">1080 x 2310</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">HUAWEI nova 5(5,5Pro)</td>
<td align="left">Android</td>
<td align="left">6.39</td>
<td align="left">403</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">HUAWEI nova 4e</td>
<td align="left">Android</td>
<td align="left">6.15</td>
<td align="left">415</td>
<td align="left">-</td>
<td align="left">360 x 771</td>
<td align="left">1080 x 2312</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">HUAWEI nova 4</td>
<td align="left">Android</td>
<td align="left">6.4</td>
<td align="left">398</td>
<td align="left">-</td>
<td align="left">360 x 770</td>
<td align="left">1080 x 2310</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">HUAWEI nova 3i</td>
<td align="left">Android</td>
<td align="left">6.3</td>
<td align="left">409</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">HUAWEI Mate30 Pro</td>
<td align="left">Android</td>
<td align="left">6.53</td>
<td align="left">409</td>
<td align="left">-</td>
<td align="left">392 x 800</td>
<td align="left">1176 x 2400</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">HUAWEI Mate30</td>
<td align="left">Android</td>
<td align="left">6.62</td>
<td align="left">409</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">HUAWEI Mate20 RS</td>
<td align="left">Android</td>
<td align="left">6.39</td>
<td align="left">538</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1440 x 3120</td>
<td align="left">4.0 xxxhdpi</td>
</tr>
<tr>
<td align="left">HUAWEI Mate20 Pro</td>
<td align="left">Android</td>
<td align="left">6.39</td>
<td align="left">538</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1440 x 3120</td>
<td align="left">4.0 xxxhdpi</td>
</tr>
<tr>
<td align="left">HUAWEI Mate20 X (X,5G)</td>
<td align="left">Android</td>
<td align="left">7.2</td>
<td align="left">345</td>
<td align="left">-</td>
<td align="left">360 x 748</td>
<td align="left">1080 x 2244</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">HUAWEI Mate20</td>
<td align="left">Android</td>
<td align="left">6.53</td>
<td align="left">381</td>
<td align="left">-</td>
<td align="left">360 x 748</td>
<td align="left">1080 x 2244</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">HUAWEI P30 Pro</td>
<td align="left">Android</td>
<td align="left">6.47</td>
<td align="left">408</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">HUAWEI P30</td>
<td align="left">Android</td>
<td align="left">6.1</td>
<td align="left">408</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">HUAWEI P20 Pro</td>
<td align="left">Android</td>
<td align="left">6.1</td>
<td align="left">408</td>
<td align="left">-</td>
<td align="left">360 x 748</td>
<td align="left">1080 x 2240</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">HUAWEI P20</td>
<td align="left">Android</td>
<td align="left">5.8</td>
<td align="left">428</td>
<td align="left">-</td>
<td align="left">360 x 748</td>
<td align="left">1080 x 2244</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">HUAWEI P10</td>
<td align="left">Android</td>
<td align="left">5.1</td>
<td align="left">432</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">1080 x 1920</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">HUAWEI P10 Plus</td>
<td align="left">Android</td>
<td align="left">5.5</td>
<td align="left">540</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">1440 x 2560</td>
<td align="left">4.0 xxxhdpi</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin学习笔记 — day1</title>
    <url>/2021/12/29/kotlin-study-day1/</url>
    <content><![CDATA[<p>个人学习记录</p>
<h2 id="1-变量与数据类型"><a href="#1-变量与数据类型" class="headerlink" title="1 变量与数据类型"></a>1 变量与数据类型</h2><blockquote>
<ul>
<li>整数类型：<code>Byte</code>、<code>Short</code>、<code>Int</code>、<code>Long</code>，<code>Int</code> 是默认类型</li>
<li>浮点类型：<code>Float</code>、<code>Double</code>，<code>Double</code>是默认类型</li>
<li>字符类型：<code>Char</code></li>
<li>布尔类型：<code>Boolean</code></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>声明只读变量，使用 <code>val</code> 关键字</li>
<li>声明可修改变量，使用 <code>var</code> 关键字</li>
</ul>
</blockquote>
<p>示例代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> maxinumAge : <span class="hljs-built_in">Int</span> = <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>类型推断：对于已声明并赋值的变量，它允许你省略类型定义</p>
</blockquote>
<p>示例代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;Hello World&quot;</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>编译时常量：</p>
<p>只能在函数之外定义，因为编译时常量必须在编译时赋值，而函数在运行时才调用，编译时常量只能是常见的数据类型。</p>
</blockquote>
<p>示例代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> MAX = <span class="hljs-number">200</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  	println(MAX)<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>查看Kotlin字节码：</p>
<p>即与java语言对比（个人理解）</p>
<p>使用方法：shift两次，输入<code>show kotlin</code>.</p>
</blockquote>
<blockquote>
<p>Kotlin只提供引用类型这一种数据类型，出于更高性能需要，Kotlin编译器会在java字节码中改用基本数据类型。（也就是Integer会转换为int）</p>
</blockquote>
<h2 id="2-表达式"><a href="#2-表达式" class="headerlink" title="2 表达式"></a>2 表达式</h2><blockquote>
<p>① <code>if/else</code>表达式与java使用一致，但：if是一个表达式，即它会返回一个值。 因此就不需要三元运算符    （条件 ? 然后 : 否则），因为普通的 if 就能胜任这个角色。</p>
<p>② ranger表达式</p>
<p>​    <code>in a..b</code>，in关键字用来检查某个值是否在指定范围内（也可用于<code>set</code>、<code>list</code>）</p>
<p>③ <code>when</code>表达式</p>
<p>​    与<code>switch/case</code>一致，当某个条件满足时，执行相应代码。</p>
</blockquote>
<p>示例代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  	<span class="hljs-keyword">val</span> age = <span class="hljs-number">3</span><br>  	<span class="hljs-keyword">if</span> (age <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.3</span>) &#123;<br>      	println(<span class="hljs-string">&quot;婴幼儿&quot;</span>)<br>       &#125;<span class="hljs-keyword">else</span> &#123;<br>      	println(<span class="hljs-string">&quot;其它&quot;</span>)<br>       &#125;<br>  <br> 	   <span class="hljs-comment">//其它用法</span><br>  	<span class="hljs-keyword">if</span> (age !<span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.3</span>)&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br> 	 <span class="hljs-keyword">val</span> x = <span class="hljs-number">1</span><br>	<span class="hljs-keyword">when</span> (x) &#123;<br>    	<span class="hljs-number">1</span> -&gt; print(<span class="hljs-string">&quot;x == 1&quot;</span>)<br>    	<span class="hljs-number">2</span> -&gt; print(<span class="hljs-string">&quot;x == 2&quot;</span>)<br>    	<span class="hljs-keyword">else</span> -&gt; &#123; <span class="hljs-comment">// 注意这个块</span><br>        	print(<span class="hljs-string">&quot;x is neither 1 nor 2&quot;</span>)<br>    	&#125;<br>	&#125;<br>  <br>    <span class="hljs-comment">//如果很多分支需要用相同的方式处理，则可以把多个分支条件放在一起，用逗号分隔：</span><br>    <span class="hljs-keyword">when</span> (x) &#123;<br>    	<span class="hljs-number">0</span>, <span class="hljs-number">1</span> -&gt; print(<span class="hljs-string">&quot;x == 0 or x == 1&quot;</span>)<br>    	<span class="hljs-keyword">else</span> -&gt; print(<span class="hljs-string">&quot;otherwise&quot;</span>)<br>	&#125;<br>  <br> 	 <span class="hljs-comment">//我们也可以检测一个值在（in）或者不在（!in）一个区间或者集合中：</span><br> 	 <span class="hljs-keyword">when</span> (x) &#123;<br>    	<span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.10</span> -&gt; print(<span class="hljs-string">&quot;x is in the range&quot;</span>)<br>    	<span class="hljs-keyword">in</span> validNumbers -&gt; print(<span class="hljs-string">&quot;x is valid&quot;</span>)<br>    	!<span class="hljs-keyword">in</span> <span class="hljs-number">10.</span><span class="hljs-number">.20</span> -&gt; print(<span class="hljs-string">&quot;x is outside the range&quot;</span>)<br>    	<span class="hljs-keyword">else</span> -&gt; print(<span class="hljs-string">&quot;none of the above&quot;</span>)<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-string模版"><a href="#3-string模版" class="headerlink" title="3 string模版"></a>3 string模版</h2><blockquote>
<p>模版支持在字符串的引号内放入变量值</p>
<p>还支持字符串里计算表达式的值并插入结果，添加在<code>$&#123;&#125;</code>中的任何表达式，都会作为字符串的一部分</p>
</blockquote>
<p>示例代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  	<span class="hljs-keyword">val</span> man = <span class="hljs-string">&quot;Jack&quot;</span><br>  	<span class="hljs-keyword">var</span> woman = <span class="hljs-string">&quot;Rose&quot;</span><br>  	println(<span class="hljs-string">&quot;<span class="hljs-variable">$man</span> Love <span class="hljs-variable">$woman</span>&quot;</span>)<br>  <br>  	<span class="hljs-keyword">var</span> flag = <span class="hljs-literal">true</span><br>  	println(<span class="hljs-string">&quot;Answer is <span class="hljs-subst">$&#123;if(flag) <span class="hljs-string">&quot;我愿意&quot;</span> else <span class="hljs-string">&quot;对不起&quot;</span>&#125;</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="4-函数"><a href="#4-函数" class="headerlink" title="4 函数"></a>4 函数</h2><blockquote>
<ul>
<li><code>private</code> <code>public</code> 可见性修饰符，默认为<code>public</code></li>
<li><code>fun</code> 函数声明关键字</li>
<li>默认值参：如果不打算传入值参，可预先指定默认值</li>
<li>具名函数参数：如果使用命名传参，可以不用管传参顺序</li>
<li>返回类型可在函数后使用 : <code>String</code> 指定，默认为Unit即无返回类型</li>
<li><code>TODO</code>函数是抛出异常（与java的throw类似），返回类型为<code>Nothing</code>。</li>
<li>函数名可以使用特殊符号、空格、中文、关键字等等，但是需要用反引号 `` 扩起来，如：java定义了关键字函数，可使用此方法。</li>
</ul>
</blockquote>
<p>示例代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//使用时 doSomething(3, true)</span><br><span class="hljs-comment">//具名使用 doSomething(age=3, flag=false)</span><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(age:<span class="hljs-type">Int</span>, flag:<span class="hljs-type">Boolean</span>)</span></span> : String&#123;<br>  	<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;result&quot;</span><br>&#125;<br><span class="hljs-comment">//使用时 fix(3)</span><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fix</span><span class="hljs-params">(age:<span class="hljs-type">Int</span>, name:<span class="hljs-type">String</span> = <span class="hljs-string">&quot;小明&quot;</span>)</span></span>&#123;<br>  	println(name + age)<br>&#125;<br><br>TODO(<span class="hljs-string">&quot;nothing&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> `*** 发对付对付 ***` <span class="hljs-params">()</span></span> &#123;<br>  	println(<span class="hljs-string">&quot;特殊函数&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin学习笔记 — day2</title>
    <url>/2022/01/03/kotlin-study-day2/</url>
    <content><![CDATA[<p>个人学习记录</p>
<h2 id="1-匿名函数"><a href="#1-匿名函数" class="headerlink" title="1 匿名函数"></a>1 匿名函数</h2><blockquote>
<p>定义时不取名字的函数，我们称之为匿名函数，匿名函数通常整体传递给其他函数，或者从其它函数返回。</p>
<p>我们将匿名函数称为lambda，将它的定义称谓lambda表达式。</p>
<p>匿名函数本质上就是一个函数的参数传递类型为<strong>函数</strong>，当这个函数作为参数传递时，它的名字也就没有意义了，所以该函数不需要再有名字，也就是 <code>a(fun(param: Int): String &#123;return param.toString()&#125;)</code>， 使用lumbda表达式简写以后就是现在匿名函数的形式了，此处可参考<a href="https://rengwuxian.com/kotlin-lambda/">扔物线Lumbda视频</a>。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  	<span class="hljs-comment">//返回字符串内s的个数</span><br>  	<span class="hljs-keyword">val</span> total = <span class="hljs-string">&quot;Mississppi&quot;</span>.count(&#123;<br>      	letter == <span class="hljs-string">&quot;s&quot;</span><br>   	 &#125;)<br>  	println(total)<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>匿名函数也有返回类型，匿名函数可以当作变量赋值给函数类型变量（<strong>实际上是有区别的，赋值后函数就变成了一个函数类型的变对象，指向原函数地址，本质上不是一个</strong>），函数的类型，由传入和返回类型决定。</p>
<p>与具名函数不一样，除极少数情况外，匿名函数不需要<code>return</code>关键字返回数据，匿名函数会把最后一行当作返回值。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> blessingFunction : () -&gt; String = &#123;<br>  	<span class="hljs-keyword">val</span> holday = <span class="hljs-string">&quot;New Year.&quot;</span><br>  	<span class="hljs-string">&quot;Happy <span class="hljs-variable">$hollday</span>&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>函数参数</p>
<p>与具名函数一样，匿名函数可以不带参数，也可以带一个或多个参数，需要带参数时，<strong>参数的类型放在匿名函数的类型定义中，参数名放在函数定义中。</strong></p>
<p>定义只有一个参数的匿名函数时，可以使用it关键字来表示参数名。（两个以上时，就不能用了）</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> main&#123;</span><br>  	<span class="hljs-keyword">var</span> blassingFunction : (String) -&gt; String &#123; name -&gt;<br>      	<span class="hljs-keyword">val</span> holiday = <span class="hljs-string">&quot;New Year.&quot;</span>.<br>      	<span class="hljs-string">&quot;<span class="hljs-variable">$name</span>, Happy <span class="hljs-variable">$holiday</span>&quot;</span><br> 	   &#125;<br>  	println(blassingFunction(<span class="hljs-string">&quot;Jacker&quot;</span>))<br>  <br>  	<span class="hljs-keyword">var</span> blassingFunction : (String) -&gt; String &#123;<br>      	<span class="hljs-keyword">val</span> holiday = <span class="hljs-string">&quot;New Year.&quot;</span>.<br>      	<span class="hljs-string">&quot;<span class="hljs-variable">$it</span>, Happy <span class="hljs-variable">$holiday</span>&quot;</span><br> 	   &#125; <br>  	println(blassingFunction(<span class="hljs-string">&quot;Jacker&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>函数的类型推断</p>
<p>声明一个函数变量时，如果已把匿名函数作为变量赋值给它，就不需要声明类型。</p>
<p>类型推断也支持带参数的匿名函数，但是函数的参数名和参数类型必须有。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> main&#123;  </span><br>  	<span class="hljs-keyword">var</span> blassingFunction &#123;<br>      	<span class="hljs-keyword">val</span> holiday = <span class="hljs-string">&quot;New Year.&quot;</span>.<br>      	<span class="hljs-string">&quot;Happy <span class="hljs-variable">$holiday</span>&quot;</span><br> 	   &#125; <br>  	println(blassingFunction())<br>  <br>  	<span class="hljs-keyword">var</span> blassingFunction = &#123; name: String,  year: <span class="hljs-built_in">Int</span> -&gt;<br>      	<span class="hljs-keyword">val</span> holiday = <span class="hljs-string">&quot;New Year.&quot;</span>.<br>      	<span class="hljs-string">&quot;<span class="hljs-variable">$name</span>, Happy <span class="hljs-variable">$holiday</span>  <span class="hljs-variable">$year</span>&quot;</span><br>   	 &#125;<br>  	println(blassingFunction(<span class="hljs-string">&quot;Jacker&quot;</span>, <span class="hljs-number">2022</span>))<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>定义参数是函数的函数</p>
<p>当lambda参数排在最后，或者是唯一的参数，那么<code>lambda</code>值参的一对圆括号可以省略，示例有一个<code>goodsname</code>，没有的话可以如示例2.</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  	showOnBoard(<span class="hljs-string">&quot;卫生纸&quot;</span>,  &#123; goodsName: String, hour: <span class="hljs-built_in">Int</span> -&gt;<br>     		<span class="hljs-keyword">val</span> currentYear = <span class="hljs-number">2022</span><br>             <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;currentYear&#125;</span>年，双11<span class="hljs-subst">$&#123;goodsName&#125;</span>促销倒计时：<span class="hljs-variable">$hour</span> 小时&quot;</span><br>   	 &#125;)<br>  	<span class="hljs-comment">//简写以后</span><br>  	showOnBoard(<span class="hljs-string">&quot;卫生纸&quot;</span>)  &#123; goodsName: String, hour: <span class="hljs-built_in">Int</span> -&gt;<br>     		<span class="hljs-keyword">val</span> currentYear = <span class="hljs-number">2022</span><br>             <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;currentYear&#125;</span>年，双11<span class="hljs-subst">$&#123;goodsName&#125;</span>促销倒计时：<span class="hljs-variable">$hour</span> 小时&quot;</span><br>   	 &#125;<br>  	<span class="hljs-comment">//简写以后 示例2</span><br>  	showOnBoard &#123; goodsName: String, hour: <span class="hljs-built_in">Int</span> -&gt;<br>     		<span class="hljs-keyword">val</span> currentYear = <span class="hljs-number">2022</span><br>             <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;currentYear&#125;</span>年，双11<span class="hljs-subst">$&#123;goodsName&#125;</span>促销倒计时：<span class="hljs-variable">$hour</span> 小时&quot;</span><br>   	 &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">showOnBoard</span><span class="hljs-params">(goodsName : <span class="hljs-type">String</span>, getDiscountWords : (<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">String</span>)</span></span>&#123;<br>  	<span class="hljs-comment">// shuffled 乱序</span><br>  	<span class="hljs-keyword">val</span> hour = (<span class="hljs-number">1.</span><span class="hljs-number">.24</span>).shuffled().last()<br>  	println(getDiscountWords(goodsName, hour))<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>lambda 与 函数类型的对象一样，在 JVM 上以对象实例的形式存在，JVM 会为所有同lambda打交道的变量分配内存，这就产生了内存开销，所以会造成性能问题。 幸运的事kotlin有一种优化机制叫内联，哪里需要lambda，编译器就会将函数复制粘贴到哪里（减少对象的创建）。</p>
<p>使用lambda的递归函数无法内联，因为会导致复制粘贴无限循环，编译器会发出警告。</p>
</blockquote>
<blockquote>
<p>要把函数作为参数给其它函数使用，除了传lambda表达式，还可以传递<strong>函数引用</strong>，函数引用可以把一个具名函数转换成一个穿参，也就是上文说的转换成函数类型的对象，使用的时候需要用<code>::method</code>引用。使用labmda表达式的地方，都可以使用函数引用。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  	showOnBoard(<span class="hljs-string">&quot;卫生纸&quot;</span>, ::getDiscountWords)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getDiscountWords</span><span class="hljs-params">(goodsName: <span class="hljs-type">String</span>, hour: <span class="hljs-type">Inte</span>)</span></span> : String&#123;<br>     	<span class="hljs-keyword">val</span> currentYear = <span class="hljs-number">2022</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;currentYear&#125;</span>年，双11<span class="hljs-subst">$&#123;goodsName&#125;</span>促销倒计时：<span class="hljs-variable">$hour</span> 小时&quot;</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">showOnBoard</span><span class="hljs-params">(goodsName : <span class="hljs-type">String</span>, getDiscountWords : (<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">String</span>)</span></span>&#123;<br>  	<span class="hljs-comment">// shuffled 乱序</span><br>  	<span class="hljs-keyword">val</span> hour = (<span class="hljs-number">1.</span><span class="hljs-number">.24</span>).shuffled().last()<br>  	println(getDiscountWords(goodsName, hour))<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>函数类型也是有效的返回类型，也就是说可以定义一个能返回函数的函数。</p>
<p><code>() :</code> 后面是返回值类型，感觉有点乱，怕忘了。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  	<span class="hljs-keyword">var</span> getDiscountWords = configDiscountWords()<br>  	println(getDiscountWords(<span class="hljs-string">&quot;沐浴露&quot;</span>))<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">configDiscountWords</span><span class="hljs-params">()</span></span> : (String) -&gt; String&#123;<br>  	<span class="hljs-keyword">val</span> currentYear = <span class="hljs-number">2022</span><br>  	<span class="hljs-keyword">val</span> hour = (<span class="hljs-number">1.</span><span class="hljs-number">.24</span>).shuffled().last()<br>  	<span class="hljs-keyword">return</span> &#123;goodsName : String -&gt; <br>  		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;currentYear&#125;</span>年，双11<span class="hljs-subst">$&#123;goodsName&#125;</span>促销倒计时：<span class="hljs-variable">$hour</span> 小时&quot;</span><br>   	 &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-闭包、lambda"><a href="#2-闭包、lambda" class="headerlink" title="2 闭包、lambda"></a>2 闭包、lambda</h2><blockquote>
<p>闭包 （为了避免变量名、方法名等等冲突，限定一个使用范围，类似java的package、class作用）</p>
<p>在Kotlin中，匿名函数能修改并引用定义在自己作用域之外的变量，匿名函数可以引用<strong>定义自身</strong>的函数里面的变量，Kotlin中的lambda就是闭包。</p>
<p>能接收函数或者返回函数的函数又叫做高级函数（也没啥高级的…，只是名字），高级函数广泛应用于函数时编程当中。</p>
</blockquote>
<p>为什么要在代码中使用函数类型？</p>
<blockquote>
<p>函数类型能让开发者少写模式化代码，（举个例子就是通过Interface传递函数，内部定义方法，对比kotlin多了个interface，比如OnClickListener）写出更灵活的代码。java8支持面向对象编程和lambda表达式，单不支持将函数作为参数传给另一个函数或变量，不过java实现方案是匿名内部类(也就是接口 + 匿名内部类实现 + 传递interface)。</p>
</blockquote>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>androidX下懒加载实现</title>
    <url>/2022/01/05/androidx-lazyload/</url>
    <content><![CDATA[<p>以前处理 Fragment 的懒加载，我们通常会在 Fragment 中处理 <code>setUserVisibleHint + onHiddenChanged</code> 这两个函数，而在 Androidx 模式下，我们可以使用 <code>FragmentTransaction.setMaxLifecycle()</code> 的方式来处理 Fragment 的懒加载。</p>
<p>在本文章中，我会详细介绍不同使用场景下两种方案的差异。大家快拿好小板凳。一起来学习新知识吧！</p>
<blockquote>
<p>本篇文章涉及到的 Demo，已上传至Github—-&gt;<a href="https://github.com/AndyJennifer/AndroidxLazyLoad">传送门</a></p>
</blockquote>
<h2 id="1-老的懒加载处理方案"><a href="#1-老的懒加载处理方案" class="headerlink" title="1 老的懒加载处理方案"></a>1 老的懒加载处理方案</h2><blockquote>
<p>如果你熟悉老一套的 Fragment 懒加载机制，你可以直接查看 Androix 懒加载相关章节</p>
</blockquote>
<h4 id="add-show-hide-模式下的老方案"><a href="#add-show-hide-模式下的老方案" class="headerlink" title="add+show+hide 模式下的老方案"></a>add+show+hide 模式下的老方案</h4><p>在没有添加懒加载之前，只要使用 <code>add+show+hide</code> 的方式控制并显示 Fragment, 那么不管 Fragment 是否嵌套，在初始化后，如果<code>只调用了add+show</code>，同级下的 Fragment 的相关生命周期函数都会被调用。且调用的生命周期函数如下所示：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">onAttach</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">onCreate</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">onCreatedView</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">onActivityCreated</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">onStart</span> -&gt;</span> onResume<br></code></pre></td></tr></table></figure>

<blockquote>
<p>Fragment 完整生命周期：onAttach -&gt; onCreate -&gt; onCreatedView -&gt; onActivityCreated -&gt; onStart -&gt; onResume -&gt; onPause -&gt; onStop -&gt; onDestroyView -&gt; onDestroy -&gt; onDetach</p>
</blockquote>
<p>什么是同级 Frament 呢？看下图</p>
<p><img  src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/19/16fb96781bfcafeb~tplv-t2oaga2asx-watermark.awebp"  ><span class="image-caption">同级Fragment.jpg</span></p>
<blockquote>
<p>上图中，都是使用 <code>add+show+hide</code> 的方式控制 Fragment,</p>
</blockquote>
<p>在上图两种模式中:</p>
<ul>
<li>Fragment_1、Fragment_2、Fragment_3 属于同级 Fragment</li>
<li>Fragment_a、Fragment_b、Fragment_c 属于同级 Fragment</li>
<li>Fragment_d、Fragment_e、Fragment_f 属于同级 Fragment</li>
</ul>
<p>那这种方式会带来什么问题呢？结合下图我们来分别分析。</p>
<p><img  src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/19/16fb967909b892db~tplv-t2oaga2asx-watermark.awebp"  ><span class="image-caption">show1.png</span></p>
<p>观察上图我们可以发现，同级的Fragment_1、Fragment_2、Fragment_3 都调用了 <code>onAttach...onResume</code> 系列方法，也就是说，如果我们没有对 Fragment 进行懒加载处理，那么我们就会无缘无故的加载一些并<code>不可见</code>的 Fragment , 也就会造成用户流量的无故消耗（我们会在 Fragment 相关生命周期函数中，请求网络或其他数据操作）。</p>
<blockquote>
<p>这里<code>&quot;不可见的Fragment&quot;</code>是指，实际不可见但是相关可见生命周期函数(如 <code>onResume</code> 方法）被调用的 Fragment</p>
</blockquote>
<p>如果使用嵌套 Fragment ，这种浪费流量的行为就更明显了。以本节的图一为例，当 Fragment_1 加载时，如果你在 Fragment_1 生命周期函数中使用 <code>show+add+hide</code> 的方式添加 <code>Fragment_a、Fragment_b、Fragment_c</code> , 那么 Fragment_b 又会在其生命周期函数中继续加载 <code>Fragment_d、Fragment_e、Fragment_f</code> 。</p>
<p>那如何解决这种问题呢？我们继续接着上面的例子走，当我们 <code>show Fragment_2</code>，并 hide其他 Fragment 时，对应 Fragment 的生命周期调用如下：</p>
<p><img  src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/19/16fb96782a90b81e~tplv-t2oaga2asx-watermark.awebp"  ><span class="image-caption">show2.png</span></p>
<p>从上图中，我们可以看出 Fragment_2 与 Fragment_3 都调用了 <code>onHiddenChanged</code> 函数，该函数的官方 API 声明如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Called when the hidden state (as returned by &#123;<span class="hljs-doctag">@link</span> #isHidden()&#125; of</span><br><span class="hljs-comment"> * the fragment has changed.  Fragments start out not hidden; this will</span><br><span class="hljs-comment"> * be called whenever the fragment changes state from that.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> hidden True if the fragment is now hidden, false otherwise.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onHiddenChanged</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> hidden)</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>根据官方 API 的注释，我们大概能知道，当 Fragment 隐藏的状态发生改变时，该函数将会被调用，如果当前 Fragment 隐藏， <code>hidden</code> 的值为 true, 反之为 false。最为重要的是<code>hidden</code> 的值，可以通过调用 <code>isHidden()</code> 函数获取。</p>
<p>那么结合上述知识点，我们能推导出：</p>
<ul>
<li>因为 Fragment_1 的 <code>隐藏状态</code> 从<code>可见转为了不可见</code>，所以其 <code>onHiddenChanged</code> 函数被调用，同时 <code>hidden</code> 的值为 true。</li>
<li>同理对于 Fragment_2 ，因为其 <code>隐藏状态</code> 从 <code>不可见转为了可见</code> ，所以其 hidden 值为 false。</li>
<li>对于 Fragment_3 ,因为其隐藏状态从始至终都没有发生变化，所以其 onHiddenChanged 函数并不会调用。</li>
</ul>
<p>嗯，好像有点眉目了。不急，我们继续看下面的例子。</p>
<p>show Fragment_3 并 hide 其他 Fragment ，对应生命周期函数调用如下所示：</p>
<p><img  src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/19/16fb967928f23799~tplv-t2oaga2asx-watermark.awebp"  ><span class="image-caption">show3.png</span></p>
<p>从图中，我们可以看出，确实只有<code>隐藏状态</code>发生了改变的 Fragment 其 <code>onHiddenChanged</code> 函数才会调用，那么结合以上知识点，我们能得出如下重要结论：</p>
<p><strong>只要通过 <code>show+hide</code> 方式控制 Fragment 的显隐，那么在第一次初始化后，Fragment 任何的生命周期方法都不会调用，只有 <code>onHiddenChanged</code> 方法会被调用。</strong></p>
<p>那么，假如我们要在 <code>add+show+hide</code> 模式下控制 Fragment 的懒加载，我们只需要做这两步：</p>
<ul>
<li>我们需要在 <code>onResume()</code> 函数中调用 <code>isHidden()</code> 函数，来处理默认显示的 Fragment</li>
<li>在 <code>onHiddenChanged</code> 函数中控制其他不可见的Fragment，</li>
</ul>
<p>也就是这样处理：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyFragment</span>:<span class="hljs-type">Fragment</span></span>()&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> isLoaded = <span class="hljs-literal">false</span> <span class="hljs-comment">//控制是否执行懒加载</span><br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onResume</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onResume()<br>        judgeLazyInit()<br><br>    &#125;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onHiddenChanged</span><span class="hljs-params">(hidden: <span class="hljs-type">Boolean</span>)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onHiddenChanged(hidden)<br>        isVisibleToUser = !hidden<br>        judgeLazyInit()<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">judgeLazyInit</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">if</span> (!isLoaded &amp;&amp; !isHidden) &#123;<br>            lazyInit()<br>            isLoaded = <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br><br>     <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDestroyView</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onDestroyView()<br>        isLoaded = <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-comment">//懒加载方法</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">lazyInit</span><span class="hljs-params">()</span></span><br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>该懒加载的实现，是在 <code>onResume</code> 方法中操作，当然你可以在其他生命周期函数中控制。但是建议在该方法中执行懒加载。</p>
</blockquote>
<h4 id="ViewPager-Fragment-模式下的老方案"><a href="#ViewPager-Fragment-模式下的老方案" class="headerlink" title="ViewPager+Fragment 模式下的老方案"></a>ViewPager+Fragment 模式下的老方案</h4><p>使用传统方式处理 ViewPager 中 Fragment 的懒加载，我们需要控制 <code>setUserVisibleHint(boolean isVisibleToUser)</code> 函数，该函数的声明如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUserVisibleHint</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> isVisibleToUser)</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure>

<p>该函数与之前我们介绍的 <code>onHiddenChanged()</code> 作用非常相似，都是通过传入的参数值来判断当前 Fragment 是否对用户可见，只是 <code>onHiddenChanged()</code> 是在 <code>add+show+hide</code> 模式下使用，而 <code>setUserVisibleHint</code> 是在 ViewPager+Fragment 模式下使用。</p>
<p>在本节中，我们用 <code>FragmentPagerAdapter + ViewPager</code> 为例，向大家讲解如何实现 Fragment 的懒加载。</p>
<blockquote>
<p>注意：在本例中没有调用 <code>setOffscreenPageLimit</code> 方法去设置 ViewPager 预缓存的 Fragment 个数。默认情况下 ViewPager 预缓存 Fragment 的个数为 <code>1</code> 。</p>
</blockquote>
<p>初始化 ViewPager 查看内部 Fragment 生命周期函数调用情况：</p>
<p><img  src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/19/16fb967817311da1~tplv-t2oaga2asx-watermark.awebp"  ><span class="image-caption">viewpager1.png</span></p>
<p>观察上图，我们能发现 ViePager 初始化时，默认会调用其内部 Fragment 的 setUserVisibleHint 方法，因为其预缓存 Fragment 个数为 <code>1</code> 的原因，所以只有 Fragment_1 与 Fragment_2 的生命周期函数被调用。</p>
<p>我们继续切换到 Fragment_2，查看各个Fragment的生命周期函数的调用变化。如下图所示：</p>
<p><img  src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/19/16fb967825d4acb4~tplv-t2oaga2asx-watermark.awebp"  ><span class="image-caption">viewpage2.png</span></p>
<p>观察上图，我们同样发现 Fragment 的 setUserVisibleHint 方法被调用了，并且 Fragment_3 的一系列生命周期函数被调用了。继续切换到 Fragment_3:</p>
<p><img  src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/19/16fb9679081837f2~tplv-t2oaga2asx-watermark.awebp"  ><span class="image-caption">viewpager_3.png</span></p>
<p>观察上图可以发现，Fragment_3 调用了 setUserVisibleHint 方法，继续又切换到 Fragment_1，查看调用函数的变化：</p>
<p><img  src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/19/16fb96782048236e~tplv-t2oaga2asx-watermark.awebp"  ><span class="image-caption">viewpager4.png</span></p>
<blockquote>
<p>因为之前在切换到 Fragment_3 时，Frafgment_1 已经走了 onDestoryView(图二，蓝色标记处) 方法，所以 Fragment_1 需要重新走一次生命周期。</p>
</blockquote>
<p>那么结合本节的三幅图，我们能得出以下结论：</p>
<ul>
<li>使用 ViewPager，切换回上一个 Fragment 页面时（已经初始化完毕），不会回调任何生命周期方法以及onHiddenChanged()，只有 setUserVisibleHint(boolean isVisibleToUser) 会被回调。</li>
<li>setUserVisibleHint(boolean isVisibleToUser) 方法总是会优先于 Fragment 生命周期函数的调用。</li>
</ul>
<p>所以如果我们想对 ViewPager 中的 Fragment 懒加载，我们需要这样处理：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyFragment</span> : <span class="hljs-type">Fragment</span></span>() &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 是否执行懒加载</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> isLoaded = <span class="hljs-literal">false</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当前Fragment是否对用户可见</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> isVisibleToUser = <span class="hljs-literal">false</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当使用ViewPager+Fragment形式会调用该方法时，setUserVisibleHint会优先Fragment生命周期函数调用，</span><br><span class="hljs-comment">     * 所以这个时候就,会导致在setUserVisibleHint方法执行时就执行了懒加载，</span><br><span class="hljs-comment">     * 而不是在onResume方法实际调用的时候执行懒加载。所以需要这个变量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> isCallResume = <span class="hljs-literal">false</span><br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onResume</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onResume()<br>        isCallResume = <span class="hljs-literal">true</span><br>        judgeLazyInit()<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">judgeLazyInit</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">if</span> (!isLoaded &amp;&amp; isVisibleToUser &amp;&amp; isCallResume) &#123;<br>            lazyInit()<br>            Log.d(TAG, <span class="hljs-string">&quot;lazyInit:!!!!!!!&quot;</span>)<br>            isLoaded = <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onHiddenChanged</span><span class="hljs-params">(hidden: <span class="hljs-type">Boolean</span>)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onHiddenChanged(hidden)<br>        isVisibleToUser = !hidden<br>        judgeLazyInit()<br>    &#125;<br><br>    <span class="hljs-comment">//在Fragment销毁View的时候，重置状态</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDestroyView</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onDestroyView()<br>        isLoaded = <span class="hljs-literal">false</span><br>        isVisibleToUser = <span class="hljs-literal">false</span><br>        isCallResume = <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setUserVisibleHint</span><span class="hljs-params">(isVisibleToUser: <span class="hljs-type">Boolean</span>)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.setUserVisibleHint(isVisibleToUser)<br>        <span class="hljs-keyword">this</span>.isVisibleToUser = isVisibleToUser<br>        judgeLazyInit()<br>    &#125;<br><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">lazyInit</span><span class="hljs-params">()</span></span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="复杂-Fragment-嵌套的情况"><a href="#复杂-Fragment-嵌套的情况" class="headerlink" title="复杂 Fragment 嵌套的情况"></a>复杂 Fragment 嵌套的情况</h4><p>当然，在实际项目中，我们可能会遇到更为复杂的 Fragment 嵌套组合。比如 Fragment+Fragment、Fragment+ViewPager、ViewPager+ViewPager….等等。 如下图所示：</p>
<p><img  src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/19/16fb96784fdd764d~tplv-t2oaga2asx-watermark.awebp"  ><span class="image-caption">复杂嵌套Fragment.jpg</span></p>
<p>对于以上场景，我们就需要重写我们的懒加载，以支持不同嵌套组合模式下 Fragment 正确懒加载。我们需要将 LazyFragment 修改成如下这样：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyFragment</span> : <span class="hljs-type">Fragment</span></span>() &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 是否执行懒加载</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> isLoaded = <span class="hljs-literal">false</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当前Fragment是否对用户可见</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> isVisibleToUser = <span class="hljs-literal">false</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当使用ViewPager+Fragment形式会调用该方法时，setUserVisibleHint会优先Fragment生命周期函数调用，</span><br><span class="hljs-comment">     * 所以这个时候就,会导致在setUserVisibleHint方法执行时就执行了懒加载，</span><br><span class="hljs-comment">     * 而不是在onResume方法实际调用的时候执行懒加载。所以需要这个变量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> isCallResume = <span class="hljs-literal">false</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 是否调用了setUserVisibleHint方法。处理show+add+hide模式下，默认可见 Fragment 不调用</span><br><span class="hljs-comment">     * onHiddenChanged 方法，进而不执行懒加载方法的问题。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> isCallUserVisibleHint = <span class="hljs-literal">false</span><br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onResume</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onResume()<br>        isCallResume = <span class="hljs-literal">true</span><br>        <span class="hljs-keyword">if</span> (!isCallUserVisibleHint) isVisibleToUser = !isHidden<br>        judgeLazyInit()<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">judgeLazyInit</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">if</span> (!isLoaded &amp;&amp; isVisibleToUser &amp;&amp; isCallResume) &#123;<br>            lazyInit()<br>            Log.d(TAG, <span class="hljs-string">&quot;lazyInit:!!!!!!!&quot;</span>)<br>            isLoaded = <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onHiddenChanged</span><span class="hljs-params">(hidden: <span class="hljs-type">Boolean</span>)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onHiddenChanged(hidden)<br>        isVisibleToUser = !hidden<br>        judgeLazyInit()<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDestroyView</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onDestroyView()<br>        isLoaded = <span class="hljs-literal">false</span><br>        isVisibleToUser = <span class="hljs-literal">false</span><br>        isCallUserVisibleHint = <span class="hljs-literal">false</span><br>        isCallResume = <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setUserVisibleHint</span><span class="hljs-params">(isVisibleToUser: <span class="hljs-type">Boolean</span>)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.setUserVisibleHint(isVisibleToUser)<br>        <span class="hljs-keyword">this</span>.isVisibleToUser = isVisibleToUser<br>        isCallUserVisibleHint = <span class="hljs-literal">true</span><br>        judgeLazyInit()<br>    &#125;<br><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">lazyInit</span><span class="hljs-params">()</span></span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Androidx-下的懒加载"><a href="#Androidx-下的懒加载" class="headerlink" title="Androidx 下的懒加载"></a>Androidx 下的懒加载</h3><p>虽然之前的方案就能解决轻松的解决 Fragment 的懒加载，但这套方案有一个最大的弊端，<code>就是不可见的 Fragment 执行了 onResume() 方法</code>。onResume 方法设计的初衷，难道不是当前 Fragment 可以和用户进行交互吗？你他妈既不可见，又不能和用户进行交互，你执行 onResume 方法干嘛？</p>
<p>基于此问题，Google 在 Androidx 在 <code>FragmentTransaction</code> 中增加了 <code>setMaxLifecycle</code> 方法来控制 Fragment 所能调用的最大的生命周期函数。如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * Set a ceiling for the state of an active fragment in this FragmentManager. If fragment is</span><br><span class="hljs-comment">  * already above the received state, it will be forced down to the correct state.</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * &lt;p&gt;The fragment provided must currently be added to the FragmentManager to have it&#x27;s</span><br><span class="hljs-comment">  * Lifecycle state capped, or previously added as part of this transaction. The</span><br><span class="hljs-comment">  * &#123;<span class="hljs-doctag">@link</span> Lifecycle.State&#125; passed in must at least be &#123;<span class="hljs-doctag">@link</span> Lifecycle.State#CREATED&#125;, otherwise</span><br><span class="hljs-comment">  * an &#123;<span class="hljs-doctag">@link</span> IllegalArgumentException&#125; will be thrown.&lt;/p&gt;</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> fragment the fragment to have it&#x27;s state capped.</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> state the ceiling state for the fragment.</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@return</span> the same FragmentTransaction instance</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-meta">@NonNull</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> FragmentTransaction <span class="hljs-title">setMaxLifecycle</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Fragment fragment,</span></span><br><span class="hljs-params"><span class="hljs-function">         <span class="hljs-meta">@NonNull</span> Lifecycle.State state)</span> </span>&#123;<br>     addOp(<span class="hljs-keyword">new</span> Op(OP_SET_MAX_LIFECYCLE, fragment, state));<br>     <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br> &#125;<br></code></pre></td></tr></table></figure>

<p>根据官方的注释，我们能知道，该方法可以设置活跃状态下 Fragment 最大的状态，如果该 Fragment 超过了设置的最大状态，那么会强制将 Fragment 降级到正确的状态。</p>
<p>那如何使用该方法呢？我们先看该方法在 Androidx 模式下 ViewPager+Fragment 模式下的使用例子。</p>
<h4 id="ViewPager-Fragment-模式下的方案"><a href="#ViewPager-Fragment-模式下的方案" class="headerlink" title="ViewPager+Fragment 模式下的方案"></a>ViewPager+Fragment 模式下的方案</h4><p>在 FragmentPagerAdapter 与 FragmentStatePagerAdapter 新增了含有  <code>behavior</code> 字段的构造函数，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FragmentPagerAdapter</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> FragmentManager fm,</span></span><br><span class="hljs-params"><span class="hljs-function">          <span class="hljs-meta">@Behavior</span> <span class="hljs-keyword">int</span> behavior)</span> </span>&#123;<br>      mFragmentManager = fm;<br>      mBehavior = behavior;<br>  &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FragmentStatePagerAdapter</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> FragmentManager fm,</span></span><br><span class="hljs-params"><span class="hljs-function">          <span class="hljs-meta">@Behavior</span> <span class="hljs-keyword">int</span> behavior)</span> </span>&#123;<br>      mFragmentManager = fm;<br>      mBehavior = behavior;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>其中 Behavior 的声明如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br> <span class="hljs-meta">@IntDef(&#123;BEHAVIOR_SET_USER_VISIBLE_HINT, BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT&#125;)</span><br> <span class="hljs-keyword">private</span> <span class="hljs-meta">@interface</span> Behavior &#123; &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * Indicates that &#123;<span class="hljs-doctag">@link</span> Fragment#setUserVisibleHint(boolean)&#125; will be called when the current</span><br><span class="hljs-comment">  * fragment changes.</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@deprecated</span> This behavior relies on the deprecated</span><br><span class="hljs-comment">  * &#123;<span class="hljs-doctag">@link</span> Fragment#setUserVisibleHint(boolean)&#125; API. Use</span><br><span class="hljs-comment">  * &#123;<span class="hljs-doctag">@link</span> #BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT&#125; to switch to its replacement,</span><br><span class="hljs-comment">  * &#123;<span class="hljs-doctag">@link</span> FragmentTransaction#setMaxLifecycle&#125;.</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@see</span> #FragmentPagerAdapter(FragmentManager, int)</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-meta">@Deprecated</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> BEHAVIOR_SET_USER_VISIBLE_HINT = <span class="hljs-number">0</span>;<br><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * Indicates that only the current fragment will be in the &#123;<span class="hljs-doctag">@link</span> Lifecycle.State#RESUMED&#125;</span><br><span class="hljs-comment">  * state. All other Fragments are capped at &#123;<span class="hljs-doctag">@link</span> Lifecycle.State#STARTED&#125;.</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@see</span> #FragmentPagerAdapter(FragmentManager, int)</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<p>从官方的注释声明中，我们能得到如下两条结论：</p>
<ul>
<li>如果 behavior 的值为 <code>BEHAVIOR_SET_USER_VISIBLE_HINT</code>，那么当 Fragment 对用户的可见状态发生改变时，<code>setUserVisibleHint</code> 方法会被调用。</li>
<li>如果 behavior 的值为 <code>BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT</code> ，那么当前选中的 Fragment 在 <code>Lifecycle.State#RESUMED</code> 状态 ，其他不可见的 Fragment 会被限制在 <code>Lifecycle.State#STARTED</code> 状态。</li>
</ul>
<p>那 BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT 这个值到底有什么作用呢？我们看下面的例子：</p>
<blockquote>
<p>在该例子中设置了 ViewPager 的适配器为 FragmentPagerAdapter 且 behavior 值为 <code>BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT</code>。</p>
</blockquote>
<p>默认初始化ViewPager，Fragment 生命周期如下所示：</p>
<p><img  src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/19/16fb967895238ac1~tplv-t2oaga2asx-watermark.awebp"  ><span class="image-caption">androix1.png</span></p>
<p>切换到 Fragment_2 时，日志情况如下所示：</p>
<p><img  src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/19/16fb96782b025a2f~tplv-t2oaga2asx-watermark.awebp"  ><span class="image-caption">androix2.png</span></p>
<p>切换到 Fragment_3 时，日志情况如下所示:</p>
<p><img  src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/19/16fb96788af81c73~tplv-t2oaga2asx-watermark.awebp"  ><span class="image-caption">androidx3.png</span></p>
<blockquote>
<p>因为篇幅的原因，本文没有在讲解 FragmentStatePagerAdapter 设置 behavior 下的使用情况，但是原理以及生命周期函数调用情况一样，感兴趣的小伙伴，可以根据  <a href="https://link.juejin.cn/?target=https://github.com/AndyJennifer/AndroidxLazyLoad">AndroidxLazyLoad</a> 项目自行测试。</p>
</blockquote>
<p>观察上述例子，我们可以发现，使用了 <code>BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT</code> 后，确实只有当前可见的 Fragment 调用了 onResume 方法。而导致产生这种改变的原因，是因为 FragmentPagerAdapter 在其 <code>setPrimaryItem</code> 方法中调用了 <code>setMaxLifecycle</code> 方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPrimaryItem</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> ViewGroup container, <span class="hljs-keyword">int</span> position, <span class="hljs-meta">@NonNull</span> Object object)</span> </span>&#123;<br>    Fragment fragment = (Fragment)object;<br>    <span class="hljs-comment">//如果当前的fragment不是当前选中并可见的Fragment,那么就会调用</span><br>    <span class="hljs-comment">// setMaxLifecycle 设置其最大生命周期为 Lifecycle.State.STARTED</span><br>    <span class="hljs-keyword">if</span> (fragment != mCurrentPrimaryItem) &#123;<br>        <span class="hljs-keyword">if</span> (mCurrentPrimaryItem != <span class="hljs-keyword">null</span>) &#123;<br>            mCurrentPrimaryItem.setMenuVisibility(<span class="hljs-keyword">false</span>);<br>            <span class="hljs-keyword">if</span> (mBehavior == BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT) &#123;<br>                <span class="hljs-keyword">if</span> (mCurTransaction == <span class="hljs-keyword">null</span>) &#123;<br>                    mCurTransaction = mFragmentManager.beginTransaction();<br>                &#125;<br>                mCurTransaction.setMaxLifecycle(mCurrentPrimaryItem, Lifecycle.State.STARTED);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                mCurrentPrimaryItem.setUserVisibleHint(<span class="hljs-keyword">false</span>);<br>            &#125;<br>        &#125;<br>    <span class="hljs-comment">//对于其他非可见的Fragment,则设置其最大生命周期为</span><br>    <span class="hljs-comment">//Lifecycle.State.RESUMED</span><br>        fragment.setMenuVisibility(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-keyword">if</span> (mBehavior == BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT) &#123;<br>            <span class="hljs-keyword">if</span> (mCurTransaction == <span class="hljs-keyword">null</span>) &#123;<br>                mCurTransaction = mFragmentManager.beginTransaction();<br>            &#125;<br>            mCurTransaction.setMaxLifecycle(fragment, Lifecycle.State.RESUMED);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            fragment.setUserVisibleHint(<span class="hljs-keyword">true</span>);<br>        &#125;<br><br>        mCurrentPrimaryItem = fragment;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>既然在上述条件下，只有实际可见的 Fragment 会调用 onResume 方法， 那是不是为我们提供了 ViewPager 下实现懒加载的新思路呢？也就是我们可以这样实现 Fragment 的懒加载：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyFragment</span> : <span class="hljs-type">Fragment</span></span>() &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> isLoaded = <span class="hljs-literal">false</span><br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onResume</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onResume()<br>        <span class="hljs-keyword">if</span> (!isLoaded) &#123;<br>            lazyInit()<br>            Log.d(TAG, <span class="hljs-string">&quot;lazyInit:!!!!!!!&quot;</span>)<br>            isLoaded = <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDestroyView</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onDestroyView()<br>        isLoaded = <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">lazyInit</span><span class="hljs-params">()</span></span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="add-show-hide-模式下的新方案"><a href="#add-show-hide-模式下的新方案" class="headerlink" title="add+show+hide 模式下的新方案"></a>add+show+hide 模式下的新方案</h4><p>虽然我们实现了Androidx 包下 ViewPager下的懒加载，但是我们仍然要考虑 add+show+hide 模式下的 Fragment 懒加载的情况，基于 ViewPager 在 <code>setPrimaryItem</code> 方法中的思路，我们可以在调用 add+show+hide 时，这样处理：</p>
<blockquote>
<p>完整的代码请点击—&gt;<a href="https://link.juejin.cn/?target=https://github.com/AndyJennifer/AndroidxLazyLoad/blob/master/app/src/main/java/com/jennifer/andy/androidxlazyload/ext/ShowHideExt.kt">ShowHideExt</a></p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用add+show+hide模式加载fragment</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 默认显示位置[showPosition]的Fragment，最大Lifecycle为Lifecycle.State.RESUMED</span><br><span class="hljs-comment"> * 其他隐藏的Fragment，最大Lifecycle为Lifecycle.State.STARTED</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *<span class="hljs-doctag">@param</span> containerViewId 容器id</span><br><span class="hljs-comment"> *<span class="hljs-doctag">@param</span> showPosition  fragments</span><br><span class="hljs-comment"> *<span class="hljs-doctag">@param</span> fragmentManager FragmentManager</span><br><span class="hljs-comment"> *<span class="hljs-doctag">@param</span> fragments  控制显示的Fragments</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadFragmentsTransaction</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-meta">@IdRes</span> containerViewId: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    showPosition: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    fragmentManager: <span class="hljs-type">FragmentManager</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">vararg</span> fragments: <span class="hljs-type">Fragment</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> (fragments.isNotEmpty()) &#123;<br>        fragmentManager.beginTransaction().apply &#123;<br>            <span class="hljs-keyword">for</span> (index <span class="hljs-keyword">in</span> fragments.indices) &#123;<br>                <span class="hljs-keyword">val</span> fragment = fragments[index]<br>                add(containerViewId, fragment, fragment.javaClass.name)<br>                <span class="hljs-keyword">if</span> (showPosition == index) &#123;<br>                    setMaxLifecycle(fragment, Lifecycle.State.RESUMED)<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    hide(fragment)<br>                    setMaxLifecycle(fragment, Lifecycle.State.STARTED)<br>                &#125;<br>            &#125;<br><br>        &#125;.commit()<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> IllegalStateException(<br>            <span class="hljs-string">&quot;fragments must not empty&quot;</span><br>        )<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/** 显示需要显示的Fragment[showFragment]，并设置其最大Lifecycle为Lifecycle.State.RESUMED。</span><br><span class="hljs-comment"> *  同时隐藏其他Fragment,并设置最大Lifecycle为Lifecycle.State.STARTED</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> fragmentManager</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> showFragment</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">showHideFragmentTransaction</span><span class="hljs-params">(fragmentManager: <span class="hljs-type">FragmentManager</span>, showFragment: <span class="hljs-type">Fragment</span>)</span></span> &#123;<br>    fragmentManager.beginTransaction().apply &#123;<br>        show(showFragment)<br>        setMaxLifecycle(showFragment, Lifecycle.State.RESUMED)<br><br>        <span class="hljs-comment">//获取其中所有的fragment,其他的fragment进行隐藏</span><br>        <span class="hljs-keyword">val</span> fragments = fragmentManager.fragments<br>        <span class="hljs-keyword">for</span> (fragment <span class="hljs-keyword">in</span> fragments) &#123;<br>            <span class="hljs-keyword">if</span> (fragment != showFragment) &#123;<br>                hide(fragment)<br>                setMaxLifecycle(fragment, Lifecycle.State.STARTED)<br>            &#125;<br>        &#125;<br>    &#125;.commit()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述代码的实现也非常简单：</p>
<ul>
<li>将需要显示的 Fragment ，在调用 add 或 show 方法后，<code>setMaxLifecycle(showFragment, Lifecycle.State.RESUMED)</code></li>
<li>将需要隐藏的 Fragment ，在调用 hide 方法后，<code>setMaxLifecycle(fragment, Lifecycle.State.STARTED)</code></li>
</ul>
<p>结合上述操作模式，查看使用 setMaxLifecycle 后，Fragment 生命周期函数调用的情况。</p>
<p>add Fragment_1、Fragment_2、Fragment_3，并 hide Fragment_2,Fragment_3 :</p>
<p><img  src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/19/16fb96794349c091~tplv-t2oaga2asx-watermark.awebp"  ><span class="image-caption">show_new1.png</span></p>
<p>show Fragment_2，hide 其他 Fragment:</p>
<p><img  src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/19/16fb9679260bc3e6~tplv-t2oaga2asx-watermark.awebp"  ><span class="image-caption">show_new2.png</span></p>
<p>show Fragment_3 hide 其他 Fragment:</p>
<p><img  src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/19/16fb967971fb39a5~tplv-t2oaga2asx-watermark.awebp"  ><span class="image-caption">show_new3.png</span></p>
<p>参考上图，好像真的也能处理懒加载！！！！！美滋滋</p>
<h5 id="并不完美的-setMaxLifecycle"><a href="#并不完美的-setMaxLifecycle" class="headerlink" title="并不完美的 setMaxLifecycle"></a>并不完美的 setMaxLifecycle</h5><p>当我第一次使用 setMaxLifycycle 方法时，我也和大家一样觉得万事大吉。但这套方案仍然有点点瑕疵，当 Fragment 的嵌套时，即使使用了 setMaxLifycycle 方法，第一次初始化时，同级不可见的Fragment，仍然 TMD 要调用可见生命周期方法。看下面的例子：</p>
<p><img  src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/19/16fb96794530f394~tplv-t2oaga2asx-watermark.awebp"  ><span class="image-caption">瑕疵.png</span></p>
<p>不知道是否是谷歌大大没有考虑到 Fragment 嵌套的情况，所以这里我们要对之前的方案就行修改，也就是如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyFragment</span> : <span class="hljs-type">Fragment</span></span>() &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> isLoaded = <span class="hljs-literal">false</span><br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onResume</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onResume()<br>        <span class="hljs-comment">//增加了Fragment是否可见的判断</span><br>        <span class="hljs-keyword">if</span> (!isLoaded &amp;&amp; !isHidden) &#123;<br>            lazyInit()<br>            Log.d(TAG, <span class="hljs-string">&quot;lazyInit:!!!!!!!&quot;</span>)<br>            isLoaded = <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDestroyView</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onDestroyView()<br>        isLoaded = <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">lazyInit</span><span class="hljs-params">()</span></span><br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上述代码中，因为同级的 Fragment 在嵌套模式下，仍然要调用 onResume 方法，所以我们增加了 Fragment 可见性的判断，这样就能保证嵌套模式下，新方案也能完美的支持 Fragment 的懒加载。</p>
<h5 id="ViewPager2-的处理方案"><a href="#ViewPager2-的处理方案" class="headerlink" title="ViewPager2 的处理方案"></a>ViewPager2 的处理方案</h5><p>ViewPager2 本身就支持对实际可见的 Fragment 才调用 onResume 方法。关于 ViewPager2 的内部机制。感兴趣的小伙伴可以自行查看源码。</p>
<p>关于 ViewPager2 的懒加载测试，已上传至 <a href="https://link.juejin.cn/?target=https://github.com/AndyJennifer/AndroidxLazyLoad">AndroidxLazyLoad</a>，大家可以结合项目查看Log日志。</p>
<h3 id="两种方式的对比与总结"><a href="#两种方式的对比与总结" class="headerlink" title="两种方式的对比与总结"></a>两种方式的对比与总结</h3><h4 id="老一套的懒加载"><a href="#老一套的懒加载" class="headerlink" title="老一套的懒加载"></a>老一套的懒加载</h4><ul>
<li>优点：不用去控制 FragmentManager的 add+show+hide 方法，所有的懒加载都是在Fragment 内部控制，也就是控制 <code>setUserVisibleHint + onHiddenChanged</code> 这两个函数。</li>
<li>缺点：实际不可见的 Fragment，其 <code>onResume</code> 方法任然会被调用，这种反常规的逻辑，无法容忍。</li>
</ul>
<h4 id="新一套的懒加载（Androidx下setMaxLifecycle）"><a href="#新一套的懒加载（Androidx下setMaxLifecycle）" class="headerlink" title="新一套的懒加载（Androidx下setMaxLifecycle）"></a>新一套的懒加载（Androidx下setMaxLifecycle）</h4><ul>
<li>优点：<code>在非特殊的情况下(缺点1)</code>，只有实际的可见 Fragment，其 <code>onResume</code> 方法才会被调用，这样才符合方法设计的初衷。</li>
<li>缺点：<ol>
<li>对于 Fragment 的嵌套，及时使用了 <code>setMaxLifecycle</code> 方法。同级不可见的Fragment， 仍然要调用 <code>onResume</code> 方法。</li>
<li>需要在原有的 add+show+hide 方法中，继续调用 setMaxLifecycle 方法来控制Fragment 的最大生命状态。</li>
</ol>
</li>
</ul>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>这两种方案的优缺点已经非常明显了，到底该选择何种懒加载模式，还是要基于大家的意愿，作者我更倾向于使用新的方案。关于 Fragment 的懒加载实现，非常愿意听到大家不同的声音，如果你有更好的方案，可以在评论区留下您的 idea，期待您的回复。如果您觉得本篇文章对你有所帮助，请不要吝啬你的关注与点赞。ღ( ´･ᴗ･` )比心</p>
<p>作者：AndyJennifer<br>链接：<a href="https://juejin.cn/post/6844904050698223624">https://juejin.cn/post/6844904050698223624</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<blockquote>
<p>以上为转载文章，以前onResume() 与 onVisiable() 某些情况用起来挺矛盾的，而且多层fragment的情况下onResume也会多次调用，还是比较推荐androidX下的方案的，当前项目内使用方法如下。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResume</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onResume();<br><br>    <span class="hljs-comment">// 使用懒加载</span><br>    <span class="hljs-keyword">if</span> (enableLazyData())<br>        onVisible();<br>&#125;<br><br><span class="hljs-comment">//默认不启用懒加载</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">enableLazyData</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><br><span class="hljs-comment">//懒加载实现</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onVisible</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (getLifecycle().getCurrentState() == Lifecycle.State.STARTED &amp;&amp; isFirst) &#123;<br>        <span class="hljs-comment">// 延迟加载 防止 切换动画还没执行完毕时数据就已经加载好了，这时页面会有渲染卡顿</span><br>        handler.postDelayed(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                initData();<br>                isFirst = <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;, <span class="hljs-number">300</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>懒加载</tag>
        <tag>androidx</tag>
      </tags>
  </entry>
</search>
