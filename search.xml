<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>scaleType 扩展 topCrop，类似centerCrop。</title>
    <url>/2021/11/12/android-image-topcrop/</url>
    <content><![CDATA[<p>为ImageView ScalType添加顶部扩展。</p>
<span id="more"></span>

<p>项目内遇到图片适配的功能，全屏展示图片，尽可能的显示完整内容，开始考虑使用centerCrop与fitStart，查询之后发现：</p>
<h3 id="1、centerCrop从中间开始展示，也就是如果长宽与空间尺寸不一致，图片的长宽都可能被裁切，不满足使用。"><a href="#1、centerCrop从中间开始展示，也就是如果长宽与空间尺寸不一致，图片的长宽都可能被裁切，不满足使用。" class="headerlink" title="1、centerCrop从中间开始展示，也就是如果长宽与空间尺寸不一致，图片的长宽都可能被裁切，不满足使用。"></a><strong>1、centerCrop从中间开始展示，也就是如果长宽与空间尺寸不一致，图片的长宽都可能被裁切，不满足使用。</strong></h3><blockquote>
<p>测试CENTER_CROP属性</p>
<p>将图片放在ImageView的中心点，然后对图片进行等比例缩放</p>
<p>官方文档描述：<br>Scale the image uniformly (maintain the image’s aspect ratio) so that<br>both dimensions (width and height) of the image will be equal to or larger<br>than the corresponding dimension of the view (minus padding).<br>这段文字值得好好体会一下。<br>简而言之：<br>等比例缩放图片使得图片的宽和高均不小于控件对应的宽高</p>
<p>1.1 若图片宽和高均小于ImageView控件的宽高，则等比例放大图片，直至铺满ImageView.<br>      当然这种情况下的等比例放大，就可能导致图片X或Y方向的图片显示不全<br>1.2 若图片宽或高小于ImageView控件的宽或高,则将图片等比例放大直到铺满ImageView<br>      比如ImageView为750<em>750,图片为600</em>800,所以会等比例放大图片，直至图片宽度变为<br>      750.但是这样会造成图片的高度大于了ImageView的高，所以图片的垂直方向显示不全，会被剪裁<br>1.3 如图片宽和高均大于ImageView控件的宽和高<br>      此时等比例缩小图片，当图片的宽高中任意一值等于控件对应的宽高时停止缩小图片。<br>      在这种情况下就很可能造成：图片显示不完整</p>
<p>所以CENTER_CROP属性的显著特点:<br>图片会铺满整个ImageView，但图片可能显示不完整<br>————————————————<br>版权声明：本文为CSDN博主「谷哥的小弟」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/lfdfhl/article/details/52144250">https://blog.csdn.net/lfdfhl/article/details/52144250</a></p>
</blockquote>
<h3 id="2、fitStart-属性完整显示图片，导致如果高度与宽度不一致，可能高度填充，宽度有白边。"><a href="#2、fitStart-属性完整显示图片，导致如果高度与宽度不一致，可能高度填充，宽度有白边。" class="headerlink" title="2、fitStart 属性完整显示图片，导致如果高度与宽度不一致，可能高度填充，宽度有白边。"></a><strong>2、fitStart 属性完整显示图片，导致如果高度与宽度不一致，可能高度填充，宽度有白边。</strong></h3><blockquote>
<p>测试FIT_CENTER属性</p>
<p>将图片放在ImageView的中心点，然后对图片进行等比例缩放</p>
<p>官方文档：<br>Scale the image using CENTER.<br>CENTER:<br>Compute a scale that will maintain the original src aspect ratio,<br>but will also ensure that src fits entirely inside dst.<br>At least one axis (X or Y) will fit exactly. The result is centered inside dst.</p>
<p>在理解了CENTER_CROP和CENTER_INSIDE之后再看FIT_CENTER就会好理解一些</p>
<p>将图片放在ImageView的中心点，对图片进行等比例缩放从而完整地显示图片</p>
<p>1.1 若图片宽和高均小于ImageView控件的宽高，则等比例放大图片<br>      直到图片的宽高中任意一值等于控件的宽或者高<br>      此情况下，图片的上下或者左右可见ImageView的背景色</p>
<p>1.2 若图片宽和高均大于ImageView控件的宽和高，则等比例缩小图片<br>      直到图片的宽高中任意一值等于控件的宽或者高<br>      所以，这也很容易导致图片的上下或者左右可见ImageView的背景色</p>
<p>1.3 若图片宽或高大于ImageView控件的宽或高<br>      这时候是该执行放大呢？还是缩小呢？<br>      其实，此时是有一个原则的：完整地显示图片。<br>      就像文档中所说：ensure that src fits entirely inside dst<br>      所以，此时会对图片进行缩放，直到图片的宽高均不大于控件的宽高</p>
<p>所以，在使用FIT_CENTER时可以完整地显示图片，而且它有一个显著的特点：<br>它使得图片的宽高中至少有一个值恰好等于控件的宽或者高。<br>这一点也是它和CENTER_INSIDE属性的主要区别</p>
<p>————————————————<br>版权声明：本文为CSDN博主「谷哥的小弟」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/lfdfhl/article/details/52144250">https://blog.csdn.net/lfdfhl/article/details/52144250</a></p>
</blockquote>
<p><strong>综合考虑，决定使用宽度填充，高度等比例缩放，多余部分填充，UI图片下方保留安全区域，与centerCrop类似，只是图片从顶部保留，自定义View如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TopCropImageView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">androidx</span>.<span class="hljs-title">appcompat</span>.<span class="hljs-title">widget</span>.<span class="hljs-title">AppCompatImageView</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TopCropImageView</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(context);<br>        setScaleType(ScaleType.MATRIX);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TopCropImageView</span><span class="hljs-params">(Context context, <span class="hljs-meta">@Nullable</span> AttributeSet attrs)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(context, attrs);<br>        setScaleType(ScaleType.MATRIX);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TopCropImageView</span><span class="hljs-params">(Context context, <span class="hljs-meta">@Nullable</span> AttributeSet attrs, <span class="hljs-keyword">int</span> defStyleAttr)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(context, attrs, defStyleAttr);<br>        setScaleType(ScaleType.MATRIX);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">setFrame</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> t, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (getDrawable() == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.setFrame(frameLeft, frameTop, frameRight, frameBottom);<br>        &#125;<br>        <span class="hljs-comment">//frame 宽度</span><br>        <span class="hljs-keyword">float</span> frameWidth = frameRight - frameLeft;<br>        <span class="hljs-comment">//图片宽度</span><br>        <span class="hljs-keyword">float</span> originalImageWidth = (<span class="hljs-keyword">float</span>)getDrawable().getIntrinsicWidth();<br>        <span class="hljs-comment">//缩放比例</span><br>        <span class="hljs-keyword">float</span> usedScaleFactor = frameWidth/originalImageWidth;<br><br>        Matrix matrix = getImageMatrix();<br>        matrix.setScale(usedScaleFactor, usedScaleFactor, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>); <br>        setImageMatrix(matrix);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.setFrame(frameLeft, frameTop, frameRight, frameBottom);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>之前在setFrame内使用getWidth（），发现部分请款返回数值为0的问题，改为使用right-left。</p>
<p>其余情况也一致，bottomCenter，left 等等，都可通过Matrix矩阵（Scale：缩放、 Skew：错切、 Rotate：旋转、Translate：平移）实现。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>屏幕尺寸大全</title>
    <url>/2021/11/12/android-screen/</url>
    <content><![CDATA[<p>常用移动设备尺寸.</p>
<span id="more"></span>

<table>
<thead>
<tr>
<th align="left">设备名称</th>
<th align="left">操作系统</th>
<th align="left">尺寸 in</th>
<th align="left">PPI</th>
<th align="left">纵横比</th>
<th align="left">宽 x 高 dp</th>
<th align="left">宽 x 高 px</th>
<th align="left">密度 dpi</th>
</tr>
</thead>
<tbody><tr>
<td align="left">iPhone 12 Pro Max</td>
<td align="left">iOS</td>
<td align="left">6.7</td>
<td align="left">458</td>
<td align="left">19 : 9</td>
<td align="left">428 x 926</td>
<td align="left">1284 x 2778</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">iPhone 12 Pro</td>
<td align="left">iOS</td>
<td align="left">6.1</td>
<td align="left">460</td>
<td align="left">19 : 9</td>
<td align="left">390 x 844</td>
<td align="left">1170 x 2532</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">iPhone 12 Mini</td>
<td align="left">iOS</td>
<td align="left">5.4</td>
<td align="left">476</td>
<td align="left">19 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">iPhone 11 Pro</td>
<td align="left">iOS</td>
<td align="left">5.8</td>
<td align="left">458</td>
<td align="left">19 : 9</td>
<td align="left">375 x 812</td>
<td align="left">1125 x 2436</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">iPhone 11 Pro Max</td>
<td align="left">iOS</td>
<td align="left">6.5</td>
<td align="left">458</td>
<td align="left">19 : 9</td>
<td align="left">414 x 896</td>
<td align="left">1242 x 2688</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">iPhone 11 （11，XR）</td>
<td align="left">iOS</td>
<td align="left">6.1</td>
<td align="left">326</td>
<td align="left">19 : 9</td>
<td align="left">414 x 896</td>
<td align="left">828 x 1792</td>
<td align="left">2.0 xhdpi</td>
</tr>
<tr>
<td align="left">iPhone XS Max</td>
<td align="left">iOS</td>
<td align="left">6.5</td>
<td align="left">458</td>
<td align="left">19 : 9</td>
<td align="left">414 x 896</td>
<td align="left">1242 x 2688</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">iPhone X (X,XS)</td>
<td align="left">iOS</td>
<td align="left">5.8</td>
<td align="left">458</td>
<td align="left">19 : 9</td>
<td align="left">375 x 812</td>
<td align="left">1125 x 2436</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">iPhone 8+ (8+, 7+, 6S+, 6+)</td>
<td align="left">iOS</td>
<td align="left">5.5</td>
<td align="left">401</td>
<td align="left">16 : 9</td>
<td align="left">414 x 736</td>
<td align="left">1242 x 2208</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">iPhone 8 (8, 7, 6S, 6)</td>
<td align="left">iOS</td>
<td align="left">4.7</td>
<td align="left">326</td>
<td align="left">16 : 9</td>
<td align="left">375 x 667</td>
<td align="left">750 x 1334</td>
<td align="left">2.0 xhdpi</td>
</tr>
<tr>
<td align="left">iPhone SE（SE, 5S, 5C）</td>
<td align="left">iOS</td>
<td align="left">4.0</td>
<td align="left">326</td>
<td align="left">16 : 9</td>
<td align="left">320 x 568</td>
<td align="left">640 x 1136</td>
<td align="left">2.0 xhdpi</td>
</tr>
<tr>
<td align="left">Android One</td>
<td align="left">Android</td>
<td align="left">4.5</td>
<td align="left">218</td>
<td align="left">16 : 9</td>
<td align="left">320 x 569</td>
<td align="left">480 x 854</td>
<td align="left">1.5 hdpi</td>
</tr>
<tr>
<td align="left">Google Pixel 3 (3,Lite)</td>
<td align="left">Android</td>
<td align="left">5.5</td>
<td align="left">439</td>
<td align="left">2:1</td>
<td align="left">360 x 720</td>
<td align="left">1080 x 2160</td>
<td align="left">3 xxhdpi</td>
</tr>
<tr>
<td align="left">Google Pixel</td>
<td align="left">Android</td>
<td align="left">5.0</td>
<td align="left">441</td>
<td align="left">16 : 9</td>
<td align="left">411 x 731</td>
<td align="left">1080 x 1920</td>
<td align="left">2.6 xxhdpi</td>
</tr>
<tr>
<td align="left">Google Pixel XL</td>
<td align="left">Android</td>
<td align="left">5.5</td>
<td align="left">534</td>
<td align="left">16 : 9</td>
<td align="left">411 x 731</td>
<td align="left">1440 x 2560</td>
<td align="left">3.5 xxxhdpi</td>
</tr>
<tr>
<td align="left">Moto Z3</td>
<td align="left">Android</td>
<td align="left">6.01</td>
<td align="left">402</td>
<td align="left">2:1</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2160</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Moto G7 PLUS</td>
<td align="left">Android</td>
<td align="left">6.24</td>
<td align="left">407</td>
<td align="left">-</td>
<td align="left">360 x 757</td>
<td align="left">1080 x 2270</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Moto 青柚1s</td>
<td align="left">Android</td>
<td align="left">5.7</td>
<td align="left">424</td>
<td align="left">2:1</td>
<td align="left">360 x 720</td>
<td align="left">1080 x 2160</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Moto P30 Note</td>
<td align="left">Android</td>
<td align="left">6.2</td>
<td align="left">402</td>
<td align="left">-</td>
<td align="left">360 x 749</td>
<td align="left">1080 x 2246</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Moto X</td>
<td align="left">Android</td>
<td align="left">4.7</td>
<td align="left">312</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">720 x 1280</td>
<td align="left">2.0 xhdpi</td>
</tr>
<tr>
<td align="left">Moto X 二代</td>
<td align="left">Android</td>
<td align="left">5.2</td>
<td align="left">424</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">1080 x 1920</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Nexus 5</td>
<td align="left">Android</td>
<td align="left">5.0</td>
<td align="left">445</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">1080 x 1920</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Nexus 5X</td>
<td align="left">Android</td>
<td align="left">5.2</td>
<td align="left">565</td>
<td align="left">16 : 9</td>
<td align="left">411 x 731</td>
<td align="left">1080 x 1920</td>
<td align="left">2.6 xxhdpi</td>
</tr>
<tr>
<td align="left">Nexus 6</td>
<td align="left">Android</td>
<td align="left">6.0</td>
<td align="left">493</td>
<td align="left">16 : 9</td>
<td align="left">411 x 731</td>
<td align="left">1440 x 2560</td>
<td align="left">3.5 xxxhdpi</td>
</tr>
<tr>
<td align="left">Nexus 6P</td>
<td align="left">Android</td>
<td align="left">5.7</td>
<td align="left">518</td>
<td align="left">16 : 9</td>
<td align="left">411 x 731</td>
<td align="left">1440 x 2560</td>
<td align="left">3.5 xxxhdpi</td>
</tr>
<tr>
<td align="left">Samsung Galaxy A70（A70，A80）</td>
<td align="left">Android</td>
<td align="left">6.7</td>
<td align="left">393</td>
<td align="left">20 : 9</td>
<td align="left">360 x 800</td>
<td align="left">1080 x 2400</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Samsung Galaxy A60</td>
<td align="left">Android</td>
<td align="left">6.3</td>
<td align="left">409</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Samsung Galaxy A40s</td>
<td align="left">Android</td>
<td align="left">6.4</td>
<td align="left">268</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">720 x 1560</td>
<td align="left">2.0 xhdpi</td>
</tr>
<tr>
<td align="left">Samsung Galaxy A8s</td>
<td align="left">Android</td>
<td align="left">6.4</td>
<td align="left">403</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Samsung Galaxy S10e</td>
<td align="left">Android</td>
<td align="left">5.8</td>
<td align="left">435</td>
<td align="left">19 : 9</td>
<td align="left">360 x 760</td>
<td align="left">1080 x 2280</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Samsung Galaxy S10+</td>
<td align="left">Android</td>
<td align="left">6.4</td>
<td align="left">526</td>
<td align="left">19 : 9</td>
<td align="left">360 x 760</td>
<td align="left">1440 x 3040</td>
<td align="left">4.0 xxxhdpi</td>
</tr>
<tr>
<td align="left">Samsung Galaxy S10</td>
<td align="left">Android</td>
<td align="left">6.1</td>
<td align="left">551</td>
<td align="left">19 : 9</td>
<td align="left">360 x 760</td>
<td align="left">1440 x 3040</td>
<td align="left">4.0 xxxhdpi</td>
</tr>
<tr>
<td align="left">Samsung Galaxy S9</td>
<td align="left">Android</td>
<td align="left">5.8</td>
<td align="left">568</td>
<td align="left">18.5 : 9</td>
<td align="left">360 x 740</td>
<td align="left">1440 x 2960</td>
<td align="left">4.0 xxxhdpi</td>
</tr>
<tr>
<td align="left">Samsung Galaxy S9+</td>
<td align="left">Android</td>
<td align="left">6.2</td>
<td align="left">531</td>
<td align="left">18.5 : 9</td>
<td align="left">360 x 740</td>
<td align="left">1440 x 2960</td>
<td align="left">4.0 xxxhdpi</td>
</tr>
<tr>
<td align="left">Samsung Galaxy S8</td>
<td align="left">Android</td>
<td align="left">5.8</td>
<td align="left">570</td>
<td align="left">18.5 : 9</td>
<td align="left">360 x 740</td>
<td align="left">1440 x 2960</td>
<td align="left">4.0 xxxhdpi</td>
</tr>
<tr>
<td align="left">Samsung Galaxy S8+</td>
<td align="left">Android</td>
<td align="left">6.2</td>
<td align="left">529</td>
<td align="left">18.5 : 9</td>
<td align="left">360 x 740</td>
<td align="left">1440 x 2960</td>
<td align="left">4.0 xxxhdpi</td>
</tr>
<tr>
<td align="left">Samsung Galaxy Note10 5G</td>
<td align="left">Android</td>
<td align="left">6.3</td>
<td align="left">534</td>
<td align="left">19 : 9</td>
<td align="left">360 x 760</td>
<td align="left">1440 x 3040</td>
<td align="left">4.0 xxxhdpi</td>
</tr>
<tr>
<td align="left">Samsung Galaxy Note10</td>
<td align="left">Android</td>
<td align="left">6.3</td>
<td align="left">400</td>
<td align="left">19 : 9</td>
<td align="left">360 x 760</td>
<td align="left">1080 x 2280</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Samsung Galaxy Note 9</td>
<td align="left">Android</td>
<td align="left">6.4</td>
<td align="left">514</td>
<td align="left">18.5 : 9</td>
<td align="left">360 x 740</td>
<td align="left">1440 x 2960</td>
<td align="left">4.0 xxxhdpi</td>
</tr>
<tr>
<td align="left">Samsung Galaxy Note 4</td>
<td align="left">Android</td>
<td align="left">5.7</td>
<td align="left">515</td>
<td align="left">16 : 9</td>
<td align="left">480 x 853</td>
<td align="left">1440 x 2560</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Samsung Galaxy Note5</td>
<td align="left">Android</td>
<td align="left">5.7</td>
<td align="left">518</td>
<td align="left">16 : 9</td>
<td align="left">480 x 853</td>
<td align="left">1440 x 2560</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Samsung Galaxy S5</td>
<td align="left">Android</td>
<td align="left">5.1</td>
<td align="left">432</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">1080 x 1920</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Samsung Galaxy S7 (S7, S6, S6 Edge)</td>
<td align="left">Android</td>
<td align="left">5.1</td>
<td align="left">576</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">1440 x 2560</td>
<td align="left">4.0 xxxhdpi</td>
</tr>
<tr>
<td align="left">Samsung Galaxy S7 Edge</td>
<td align="left">Android</td>
<td align="left">5.5</td>
<td align="left">534</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">1440 x 2560</td>
<td align="left">4.0 xxxhdpi</td>
</tr>
<tr>
<td align="left">Smartisan T2</td>
<td align="left">Android</td>
<td align="left">4.95</td>
<td align="left">445</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">1080 x 1920</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Smartisan M1</td>
<td align="left">Android</td>
<td align="left">5.15</td>
<td align="left">428</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">1080 x 1920</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Smartisan M1L</td>
<td align="left">Android</td>
<td align="left">5.7</td>
<td align="left">515</td>
<td align="left">16 : 9</td>
<td align="left">480 x 853</td>
<td align="left">1440 x 2560</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">坚果 R1</td>
<td align="left">Android</td>
<td align="left">6.17</td>
<td align="left">403</td>
<td align="left">-</td>
<td align="left">360 x 640</td>
<td align="left">1080 x 2242</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">坚果 3</td>
<td align="left">Android</td>
<td align="left">5.99</td>
<td align="left">403</td>
<td align="left">2:1</td>
<td align="left">360 x 720</td>
<td align="left">1080 x 2160</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">坚果 Pro2s</td>
<td align="left">Android</td>
<td align="left">6.01</td>
<td align="left">402</td>
<td align="left">2:1</td>
<td align="left">360 x 720</td>
<td align="left">1080 x 2160</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">坚果 Pro2</td>
<td align="left">Android</td>
<td align="left">6.01</td>
<td align="left">403</td>
<td align="left">2:1</td>
<td align="left">360 x 720</td>
<td align="left">1080 x 2160</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">坚果 Pro</td>
<td align="left">Android</td>
<td align="left">5.5</td>
<td align="left">403</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">1080 x 1920</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">OnePlus 7 Pro</td>
<td align="left">Android</td>
<td align="left">6.67</td>
<td align="left">516</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1440 x 3120</td>
<td align="left">4.0 xxxhdpi</td>
</tr>
<tr>
<td align="left">OnePlus 7</td>
<td align="left">Android</td>
<td align="left">6.41</td>
<td align="left">402</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">OnePlus 5</td>
<td align="left">Android</td>
<td align="left">5.5</td>
<td align="left">401</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">1080 x 1920</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">OnePlus 6T</td>
<td align="left">Android</td>
<td align="left">6.41</td>
<td align="left">402</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">OnePlus 3T</td>
<td align="left">Android</td>
<td align="left">5.5</td>
<td align="left">401</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">1080 x 1920</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Oppo R9s (R9s, R11)</td>
<td align="left">Android</td>
<td align="left">5.5</td>
<td align="left">401</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">1080 x 1920</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Oppo R9s Plus (R9s Plus, R11 Plus)</td>
<td align="left">Android</td>
<td align="left">6.0</td>
<td align="left">368</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">1080 x 1920</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Oppo Find X</td>
<td align="left">Android</td>
<td align="left">6.42</td>
<td align="left">401</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Oppo Reno2</td>
<td align="left">Android</td>
<td align="left">6.5</td>
<td align="left">401</td>
<td align="left">-</td>
<td align="left">360 x 800</td>
<td align="left">1080 x 2400</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Oppo Reno</td>
<td align="left">Android</td>
<td align="left">6.4</td>
<td align="left">402</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Oppo Reno 10</td>
<td align="left">Android</td>
<td align="left">6.6</td>
<td align="left">387</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Oppo Reno Z</td>
<td align="left">Android</td>
<td align="left">6.4</td>
<td align="left">402</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Oppo R15x (R15x,R17,R17 Pro)</td>
<td align="left">Android</td>
<td align="left">6.4</td>
<td align="left">402</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Oppo K3</td>
<td align="left">Android</td>
<td align="left">6.5</td>
<td align="left">394</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Oppo A9(A9,A9x)</td>
<td align="left">Android</td>
<td align="left">6.53</td>
<td align="left">394</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Oppo A7</td>
<td align="left">Android</td>
<td align="left">6.2</td>
<td align="left">271</td>
<td align="left">19 : 9</td>
<td align="left">360 x 760</td>
<td align="left">720 x 1520</td>
<td align="left">2.0 xhdpi</td>
</tr>
<tr>
<td align="left">Oppo A7x</td>
<td align="left">Android</td>
<td align="left">6.3</td>
<td align="left">409</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Oppo A5</td>
<td align="left">Android</td>
<td align="left">6.2</td>
<td align="left">271</td>
<td align="left">19 : 9</td>
<td align="left">360 x 760</td>
<td align="left">720 x 1520</td>
<td align="left">2.0 xhdpi</td>
</tr>
<tr>
<td align="left">Oppo A57</td>
<td align="left">Android</td>
<td align="left">5.2</td>
<td align="left">282</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">720 x 1280</td>
<td align="left">2.0 xhdpi</td>
</tr>
<tr>
<td align="left">Oppo A59s</td>
<td align="left">Android</td>
<td align="left">5.5</td>
<td align="left">267</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">720 x 1280</td>
<td align="left">2.0 xhdpi</td>
</tr>
<tr>
<td align="left">Oppo A37</td>
<td align="left">Android</td>
<td align="left">5.0</td>
<td align="left">293</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">720 x 1280</td>
<td align="left">2.0 xhdpi</td>
</tr>
<tr>
<td align="left">小米10（至尊纪念版）</td>
<td align="left">Android</td>
<td align="left">6.67</td>
<td align="left">386</td>
<td align="left">13 : 6</td>
<td align="left">-</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">小米10 Pro</td>
<td align="left">Android</td>
<td align="left">6.67</td>
<td align="left">395</td>
<td align="left">20 : 9</td>
<td align="left">-</td>
<td align="left">1080 x 2400</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">小米CC9</td>
<td align="left">Android</td>
<td align="left">6.39</td>
<td align="left">403</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">小米CC9e</td>
<td align="left">Android</td>
<td align="left">6.088</td>
<td align="left">282</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">720 x 1560</td>
<td align="left">2.0 xhdpi</td>
</tr>
<tr>
<td align="left">小米9 (9,9Pro 5G)</td>
<td align="left">Android</td>
<td align="left">6.39</td>
<td align="left">403</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">小米MIX Alpha 5G</td>
<td align="left">Android</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">- -</td>
</tr>
<tr>
<td align="left">小米MIX3</td>
<td align="left">Android</td>
<td align="left">6.39</td>
<td align="left">403</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">小米MIX2 (MIX2,MIX2s)</td>
<td align="left">Android</td>
<td align="left">5.99</td>
<td align="left">403</td>
<td align="left">2:1</td>
<td align="left">360 x 720</td>
<td align="left">1080 x 2160</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">小米MIX</td>
<td align="left">Android</td>
<td align="left">6.4</td>
<td align="left">362</td>
<td align="left">-</td>
<td align="left">360 x 680</td>
<td align="left">1080 x 2040</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">小米Note 3</td>
<td align="left">Android</td>
<td align="left">5.5</td>
<td align="left">403</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">1080 x 1920</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">小米Note 2</td>
<td align="left">Android</td>
<td align="left">5.7</td>
<td align="left">386</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">1080 x 1920</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">小米6</td>
<td align="left">Android</td>
<td align="left">5.15</td>
<td align="left">428</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">1080 x 1920</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">小米5s</td>
<td align="left">Android</td>
<td align="left">5.15</td>
<td align="left">428</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">1080 x 1920</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">小米5s Plus</td>
<td align="left">Android</td>
<td align="left">5.7</td>
<td align="left">386</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">1080 x 1920</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">小米Max</td>
<td align="left">Android</td>
<td align="left">6.44</td>
<td align="left">342</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">1080 x 1920</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">红米K20 (K20,K20 Pro,K20 Pro尊享)</td>
<td align="left">Android</td>
<td align="left">6.39</td>
<td align="left">403</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">红米Note 7 (7,7 Pro,8,8 Pro)</td>
<td align="left">Android</td>
<td align="left">6.3</td>
<td align="left">409</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">红米Note 4 (4, Note 4X)</td>
<td align="left">Android</td>
<td align="left">5.5</td>
<td align="left">403</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">1080 x 1920</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">红米 4 (4, 4X)</td>
<td align="left">Android</td>
<td align="left">5.0</td>
<td align="left">296</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">720 x 1280</td>
<td align="left">2.0 xhdpi</td>
</tr>
<tr>
<td align="left">NEX双屏版</td>
<td align="left">Android</td>
<td align="left">6.39/5.49</td>
<td align="left">404</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Vivo Y7s</td>
<td align="left">Android</td>
<td align="left">6.38</td>
<td align="left">404</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Vivo Y3</td>
<td align="left">Android</td>
<td align="left">6.35</td>
<td align="left">268</td>
<td align="left">-</td>
<td align="left">360 x 772</td>
<td align="left">720 x 1544</td>
<td align="left">2.0 xhdpi</td>
</tr>
<tr>
<td align="left">Vivo Y91(Y91,Y93,Y93s)</td>
<td align="left">Android</td>
<td align="left">6.2</td>
<td align="left">270</td>
<td align="left">19 : 9</td>
<td align="left">360 x 760</td>
<td align="left">720 x 1520</td>
<td align="left">2.0 xhdpi</td>
</tr>
<tr>
<td align="left">Vivo U1</td>
<td align="left">Android</td>
<td align="left">6.2</td>
<td align="left">270</td>
<td align="left">19 : 9</td>
<td align="left">360 x 760</td>
<td align="left">720 x 1520</td>
<td align="left">2.0 xhdpi</td>
</tr>
<tr>
<td align="left">Vivo S1 Pro</td>
<td align="left">Android</td>
<td align="left">6.39</td>
<td align="left">394</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Vivo S1</td>
<td align="left">Android</td>
<td align="left">6.53</td>
<td align="left">394</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Vivo X27 Pro</td>
<td align="left">Android</td>
<td align="left">6.7</td>
<td align="left">401</td>
<td align="left">-</td>
<td align="left">360 x 820</td>
<td align="left">1080 x 2460</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Vivo X27</td>
<td align="left">Android</td>
<td align="left">6.39</td>
<td align="left">394</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Vivo Z5x</td>
<td align="left">Android</td>
<td align="left">6.53</td>
<td align="left">386</td>
<td align="left">19 : 9</td>
<td align="left">360 x 760</td>
<td align="left">1080 x 2280</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Vivo Z5</td>
<td align="left">Android</td>
<td align="left">6.38</td>
<td align="left">404</td>
<td align="left">19 : 9</td>
<td align="left">360 x 760</td>
<td align="left">1080 x 2280</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Vivo Z3</td>
<td align="left">Android</td>
<td align="left">6.3</td>
<td align="left">403</td>
<td align="left">19 : 9</td>
<td align="left">360 x 760</td>
<td align="left">1080 x 2280</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Vivo iQOO Neo</td>
<td align="left">Android</td>
<td align="left">6.38</td>
<td align="left">403</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Vivo iQOO</td>
<td align="left">Android</td>
<td align="left">6.41</td>
<td align="left">402</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Vivo X9 (X9, X9s)</td>
<td align="left">Android</td>
<td align="left">5.5</td>
<td align="left">401</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">1080 x 1920</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Vivo X9 Plus (X9 Plus, X9s Plus)</td>
<td align="left">Android</td>
<td align="left">5.88</td>
<td align="left">375</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">1080 x 1920</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Huawei P40 Pro+</td>
<td align="left">Android</td>
<td align="left">6.58</td>
<td align="left">441</td>
<td align="left">11 : 5</td>
<td align="left">-</td>
<td align="left">1200 x 2640</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">Huawei P40 Pro</td>
<td align="left">Android</td>
<td align="left">6.58</td>
<td align="left">441</td>
<td align="left">11 : 5</td>
<td align="left">-</td>
<td align="left">1200 x 2640</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">HUAWEI nova 5i</td>
<td align="left">Android</td>
<td align="left">6.4</td>
<td align="left">398</td>
<td align="left">-</td>
<td align="left">360 x 770</td>
<td align="left">1080 x 2310</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">HUAWEI nova 5(5,5Pro)</td>
<td align="left">Android</td>
<td align="left">6.39</td>
<td align="left">403</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">HUAWEI nova 4e</td>
<td align="left">Android</td>
<td align="left">6.15</td>
<td align="left">415</td>
<td align="left">-</td>
<td align="left">360 x 771</td>
<td align="left">1080 x 2312</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">HUAWEI nova 4</td>
<td align="left">Android</td>
<td align="left">6.4</td>
<td align="left">398</td>
<td align="left">-</td>
<td align="left">360 x 770</td>
<td align="left">1080 x 2310</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">HUAWEI nova 3i</td>
<td align="left">Android</td>
<td align="left">6.3</td>
<td align="left">409</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">HUAWEI Mate30 Pro</td>
<td align="left">Android</td>
<td align="left">6.53</td>
<td align="left">409</td>
<td align="left">-</td>
<td align="left">392 x 800</td>
<td align="left">1176 x 2400</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">HUAWEI Mate30</td>
<td align="left">Android</td>
<td align="left">6.62</td>
<td align="left">409</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">HUAWEI Mate20 RS</td>
<td align="left">Android</td>
<td align="left">6.39</td>
<td align="left">538</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1440 x 3120</td>
<td align="left">4.0 xxxhdpi</td>
</tr>
<tr>
<td align="left">HUAWEI Mate20 Pro</td>
<td align="left">Android</td>
<td align="left">6.39</td>
<td align="left">538</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1440 x 3120</td>
<td align="left">4.0 xxxhdpi</td>
</tr>
<tr>
<td align="left">HUAWEI Mate20 X (X,5G)</td>
<td align="left">Android</td>
<td align="left">7.2</td>
<td align="left">345</td>
<td align="left">-</td>
<td align="left">360 x 748</td>
<td align="left">1080 x 2244</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">HUAWEI Mate20</td>
<td align="left">Android</td>
<td align="left">6.53</td>
<td align="left">381</td>
<td align="left">-</td>
<td align="left">360 x 748</td>
<td align="left">1080 x 2244</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">HUAWEI P30 Pro</td>
<td align="left">Android</td>
<td align="left">6.47</td>
<td align="left">408</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">HUAWEI P30</td>
<td align="left">Android</td>
<td align="left">6.1</td>
<td align="left">408</td>
<td align="left">19.5 : 9</td>
<td align="left">360 x 780</td>
<td align="left">1080 x 2340</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">HUAWEI P20 Pro</td>
<td align="left">Android</td>
<td align="left">6.1</td>
<td align="left">408</td>
<td align="left">-</td>
<td align="left">360 x 748</td>
<td align="left">1080 x 2240</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">HUAWEI P20</td>
<td align="left">Android</td>
<td align="left">5.8</td>
<td align="left">428</td>
<td align="left">-</td>
<td align="left">360 x 748</td>
<td align="left">1080 x 2244</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">HUAWEI P10</td>
<td align="left">Android</td>
<td align="left">5.1</td>
<td align="left">432</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">1080 x 1920</td>
<td align="left">3.0 xxhdpi</td>
</tr>
<tr>
<td align="left">HUAWEI P10 Plus</td>
<td align="left">Android</td>
<td align="left">5.5</td>
<td align="left">540</td>
<td align="left">16 : 9</td>
<td align="left">360 x 640</td>
<td align="left">1440 x 2560</td>
<td align="left">4.0 xxxhdpi</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin变量、函数、表达式</title>
    <url>/2021/12/29/kotlin-study-day1/</url>
    <content><![CDATA[<p>Kotlin基础知识</p>
<span id="more"></span>

<h2 id="1-变量与数据类型"><a href="#1-变量与数据类型" class="headerlink" title="1 变量与数据类型"></a>1 变量与数据类型</h2><blockquote>
<ul>
<li>整数类型：<code>Byte</code>、<code>Short</code>、<code>Int</code>、<code>Long</code>，<code>Int</code> 是默认类型</li>
<li>浮点类型：<code>Float</code>、<code>Double</code>，<code>Double</code>是默认类型</li>
<li>字符类型：<code>Char</code></li>
<li>布尔类型：<code>Boolean</code></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>声明只读变量，使用 <code>val</code> 关键字</li>
<li>声明可修改变量，使用 <code>var</code> 关键字</li>
</ul>
</blockquote>
<p>示例代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> maxinumAge : <span class="hljs-built_in">Int</span> = <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>类型推断：对于已声明并赋值的变量，它允许你省略类型定义</p>
</blockquote>
<p>示例代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;Hello World&quot;</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>编译时常量：</p>
<p>只能在函数之外定义，因为编译时常量必须在编译时赋值，而函数在运行时才调用，编译时常量只能是常见的数据类型。</p>
</blockquote>
<p>示例代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> MAX = <span class="hljs-number">200</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	println(MAX)<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>查看Kotlin字节码：</p>
<p>即与java语言对比（个人理解）</p>
<p>使用方法：shift两次，输入<code>show kotlin</code>.</p>
</blockquote>
<blockquote>
<p>Kotlin只提供引用类型这一种数据类型，出于更高性能需要，Kotlin编译器会在java字节码中改用基本数据类型。（也就是Integer会转换为int）</p>
</blockquote>
<h2 id="2-表达式"><a href="#2-表达式" class="headerlink" title="2 表达式"></a>2 表达式</h2><blockquote>
<p>① <code>if/else</code>表达式与java使用一致，但：if是一个表达式，即它会返回一个值。 因此就不需要三元运算符    （条件 ? 然后 : 否则），因为普通的 if 就能胜任这个角色。</p>
<p>② ranger表达式</p>
<p>​    <code>in a..b</code>，in关键字用来检查某个值是否在指定范围内（也可用于<code>set</code>、<code>list</code>）</p>
<p>③ <code>when</code>表达式</p>
<p>​    与<code>switch/case</code>一致，当某个条件满足时，执行相应代码。</p>
</blockquote>
<p>示例代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">val</span> age = <span class="hljs-number">3</span><br>	<span class="hljs-keyword">if</span> (age <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.3</span>) &#123;<br>		println(<span class="hljs-string">&quot;婴幼儿&quot;</span>)<br>	&#125;<span class="hljs-keyword">else</span> &#123;<br>		println(<span class="hljs-string">&quot;其它&quot;</span>)<br>	&#125;<br><br> 	  <span class="hljs-comment">//其它用法</span><br>	<span class="hljs-keyword">if</span> (age !<span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.3</span>)&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">val</span> x = <span class="hljs-number">1</span><br>	<span class="hljs-keyword">when</span> (x) &#123;<br>    	<span class="hljs-number">1</span> -&gt; print(<span class="hljs-string">&quot;x == 1&quot;</span>)<br>    	<span class="hljs-number">2</span> -&gt; print(<span class="hljs-string">&quot;x == 2&quot;</span>)<br>    	<span class="hljs-keyword">else</span> -&gt; &#123; <span class="hljs-comment">// 注意这个块</span><br>        	print(<span class="hljs-string">&quot;x is neither 1 nor 2&quot;</span>)<br>    	&#125;<br>	&#125;<br>  <br>    <span class="hljs-comment">//如果很多分支需要用相同的方式处理，则可以把多个分支条件放在一起，用逗号分隔：</span><br>    <span class="hljs-keyword">when</span> (x) &#123;<br>    	<span class="hljs-number">0</span>, <span class="hljs-number">1</span> -&gt; print(<span class="hljs-string">&quot;x == 0 or x == 1&quot;</span>)<br>    	<span class="hljs-keyword">else</span> -&gt; print(<span class="hljs-string">&quot;otherwise&quot;</span>)<br>	&#125;<br>  <br> 	 <span class="hljs-comment">//我们也可以检测一个值在（in）或者不在（!in）一个区间或者集合中：</span><br> 	 <span class="hljs-keyword">when</span> (x) &#123;<br>    	<span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.10</span> -&gt; print(<span class="hljs-string">&quot;x is in the range&quot;</span>)<br>    	<span class="hljs-keyword">in</span> validNumbers -&gt; print(<span class="hljs-string">&quot;x is valid&quot;</span>)<br>    	!<span class="hljs-keyword">in</span> <span class="hljs-number">10.</span><span class="hljs-number">.20</span> -&gt; print(<span class="hljs-string">&quot;x is outside the range&quot;</span>)<br>    	<span class="hljs-keyword">else</span> -&gt; print(<span class="hljs-string">&quot;none of the above&quot;</span>)<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-string模版"><a href="#3-string模版" class="headerlink" title="3 string模版"></a>3 string模版</h2><blockquote>
<p>模版支持在字符串的引号内放入变量值</p>
<p>还支持字符串里计算表达式的值并插入结果，添加在<code>$&#123;&#125;</code>中的任何表达式，都会作为字符串的一部分</p>
</blockquote>
<p>示例代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  	<span class="hljs-keyword">val</span> man = <span class="hljs-string">&quot;Jack&quot;</span><br>  	<span class="hljs-keyword">var</span> woman = <span class="hljs-string">&quot;Rose&quot;</span><br>  	println(<span class="hljs-string">&quot;<span class="hljs-variable">$man</span> Love <span class="hljs-variable">$woman</span>&quot;</span>)<br>  <br>  	<span class="hljs-keyword">var</span> flag = <span class="hljs-literal">true</span><br>  	println(<span class="hljs-string">&quot;Answer is <span class="hljs-subst">$&#123;if(flag) <span class="hljs-string">&quot;我愿意&quot;</span> else <span class="hljs-string">&quot;对不起&quot;</span>&#125;</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="4-函数"><a href="#4-函数" class="headerlink" title="4 函数"></a>4 函数</h2><blockquote>
<ul>
<li><code>private</code> <code>public</code> 可见性修饰符，默认为<code>public</code></li>
<li><code>fun</code> 函数声明关键字</li>
<li>默认值参：如果不打算传入值参，可预先指定默认值</li>
<li>具名函数参数：如果使用命名传参，可以不用管传参顺序</li>
<li>返回类型可在函数后使用 : <code>String</code> 指定，默认为Unit即无返回类型</li>
<li><code>TODO</code>函数是抛出异常（与java的throw类似），返回类型为<code>Nothing</code>。</li>
<li>函数名可以使用特殊符号、空格、中文、关键字等等，但是需要用反引号 `` 扩起来，如：java定义了关键字函数，可使用此方法。</li>
</ul>
</blockquote>
<p>示例代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//使用时 doSomething(3, true)</span><br><span class="hljs-comment">//具名使用 doSomething(age=3, flag=false)</span><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(age:<span class="hljs-type">Int</span>, flag:<span class="hljs-type">Boolean</span>)</span></span> : String&#123;<br>  	<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;result&quot;</span><br>&#125;<br><span class="hljs-comment">//使用时 fix(3)</span><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fix</span><span class="hljs-params">(age:<span class="hljs-type">Int</span>, name:<span class="hljs-type">String</span> = <span class="hljs-string">&quot;小明&quot;</span>)</span></span>&#123;<br>  	println(name + age)<br>&#125;<br><br>TODO(<span class="hljs-string">&quot;nothing&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> `*** 发对付对付 ***` <span class="hljs-params">()</span></span> &#123;<br>  	println(<span class="hljs-string">&quot;特殊函数&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin匿名函数</title>
    <url>/2022/01/03/kotlin-study-day2/</url>
    <content><![CDATA[<p>匿名函数与lambda</p>
<span id="more"></span>

<h2 id="1-匿名函数"><a href="#1-匿名函数" class="headerlink" title="1 匿名函数"></a>1 匿名函数</h2><h3 id="匿名函数定义"><a href="#匿名函数定义" class="headerlink" title="匿名函数定义"></a>匿名函数定义</h3><p>定义时不取名字的函数，我们称之为匿名函数，匿名函数通常整体传递给其他函数，或者从其它函数返回。</p>
<p>我们将匿名函数称为lambda，将它的定义称谓lambda表达式。</p>
<p>匿名函数本质上就是一个函数的参数传递类型为<strong>函数</strong>，当这个函数作为参数传递时，它的名字也就没有意义了，所以该函数不需要再有名字，也就是 <code>a(fun(param: Int): String &#123;return param.toString()&#125;)</code>， 使用lumbda表达式简写以后就是现在匿名函数的形式了，此处可参考<a href="https://rengwuxian.com/kotlin-lambda/">扔物线Lumbda视频</a>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  	<span class="hljs-comment">//返回字符串内s的个数</span><br>  	<span class="hljs-keyword">val</span> total = <span class="hljs-string">&quot;Mississppi&quot;</span>.count(&#123;<br>      	letter == <span class="hljs-string">&quot;s&quot;</span><br>   	 &#125;)<br>  	println(total)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="匿名函数返回类型"><a href="#匿名函数返回类型" class="headerlink" title="匿名函数返回类型"></a>匿名函数返回类型</h3><p>匿名函数也有返回类型，匿名函数可以当作变量赋值给函数类型变量（<strong>实际上是有区别的，赋值后函数就变成了一个函数类型的变对象，指向原函数地址，本质上不是一个</strong>），函数的类型，由传入和返回类型决定。</p>
<p>与具名函数不一样，除极少数情况外，匿名函数不需要<code>return</code>关键字返回数据，匿名函数会把最后一行当作返回值。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> blessingFunction : () -&gt; String = &#123;<br>  	<span class="hljs-keyword">val</span> holday = <span class="hljs-string">&quot;New Year.&quot;</span><br>  	<span class="hljs-string">&quot;Happy <span class="hljs-variable">$hollday</span>&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="单表达式函数"><a href="#单表达式函数" class="headerlink" title="单表达式函数"></a>单表达式函数</h3><p>当函数返回单个表达式时，可以省略花括号并且在 <code>=</code> 符号之后指定代码体即可</p>
<p>当返回值类型可由编译器推断时，显式声明返回类型是可选的</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 示例1</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">double</span><span class="hljs-params">(x: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> = x * <span class="hljs-number">2</span><br><span class="hljs-comment">// 示例2</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">special</span><span class="hljs-params">()</span></span> = <span class="hljs-string">&quot;LuxuryProduct special function&quot;</span><br></code></pre></td></tr></table></figure>

<h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>与具名函数一样，匿名函数可以不带参数，也可以带一个或多个参数，需要带参数时，<strong>参数的类型放在匿名函数的类型定义中，参数名放在函数定义中。</strong></p>
<p>定义只有一个参数的匿名函数时，可以使用it关键字来表示参数名。（两个以上时，就不能用了）</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> main&#123;</span><br>  	<span class="hljs-keyword">var</span> blassingFunction : (String) -&gt; String &#123; name -&gt;<br>      	<span class="hljs-keyword">val</span> holiday = <span class="hljs-string">&quot;New Year.&quot;</span>.<br>      	<span class="hljs-string">&quot;<span class="hljs-variable">$name</span>, Happy <span class="hljs-variable">$holiday</span>&quot;</span><br> 	   &#125;<br>  	println(blassingFunction(<span class="hljs-string">&quot;Jacker&quot;</span>))<br>  <br>  	<span class="hljs-keyword">var</span> blassingFunction : (String) -&gt; String &#123;<br>      	<span class="hljs-keyword">val</span> holiday = <span class="hljs-string">&quot;New Year.&quot;</span>.<br>      	<span class="hljs-string">&quot;<span class="hljs-variable">$it</span>, Happy <span class="hljs-variable">$holiday</span>&quot;</span><br> 	   &#125; <br>  	println(blassingFunction(<span class="hljs-string">&quot;Jacker&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="函数的类型推断"><a href="#函数的类型推断" class="headerlink" title="函数的类型推断"></a>函数的类型推断</h3><p>声明一个函数变量时，如果已把匿名函数作为变量赋值给它，就不需要声明类型。</p>
<p>类型推断也支持带参数的匿名函数，但是函数的参数名和参数类型必须有。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> main&#123;  </span><br>  	<span class="hljs-keyword">var</span> blassingFunction &#123;<br>      	<span class="hljs-keyword">val</span> holiday = <span class="hljs-string">&quot;New Year.&quot;</span>.<br>      	<span class="hljs-string">&quot;Happy <span class="hljs-variable">$holiday</span>&quot;</span><br> 	   &#125; <br>  	println(blassingFunction())<br>  <br>  	<span class="hljs-keyword">var</span> blassingFunction = &#123; name: String,  year: <span class="hljs-built_in">Int</span> -&gt;<br>      	<span class="hljs-keyword">val</span> holiday = <span class="hljs-string">&quot;New Year.&quot;</span>.<br>      	<span class="hljs-string">&quot;<span class="hljs-variable">$name</span>, Happy <span class="hljs-variable">$holiday</span>  <span class="hljs-variable">$year</span>&quot;</span><br>   	 &#125;<br>  	println(blassingFunction(<span class="hljs-string">&quot;Jacker&quot;</span>, <span class="hljs-number">2022</span>))<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="定义参数是函数的函数"><a href="#定义参数是函数的函数" class="headerlink" title="定义参数是函数的函数"></a>定义参数是函数的函数</h3><p>当lambda参数排在最后，或者是唯一的参数，那么<code>lambda</code>值参的一对圆括号可以省略，示例有一个<code>goodsname</code>，没有的话可以如示例2.</p>
<p>或者说成：如果在默认参数之后的最后一个参数是 <code>lambda</code> 表达式，那么它既可以作为命名参数在括号内传入，也可以在括号外传入：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  	showOnBoard(<span class="hljs-string">&quot;卫生纸&quot;</span>,  &#123; goodsName: String, hour: <span class="hljs-built_in">Int</span> -&gt;<br>     		<span class="hljs-keyword">val</span> currentYear = <span class="hljs-number">2022</span><br>             <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;currentYear&#125;</span>年，双11<span class="hljs-subst">$&#123;goodsName&#125;</span>促销倒计时：<span class="hljs-variable">$hour</span> 小时&quot;</span><br>   	 &#125;)<br>  	<span class="hljs-comment">//简写以后</span><br>  	showOnBoard(<span class="hljs-string">&quot;卫生纸&quot;</span>)  &#123; goodsName: String, hour: <span class="hljs-built_in">Int</span> -&gt;<br>     		<span class="hljs-keyword">val</span> currentYear = <span class="hljs-number">2022</span><br>             <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;currentYear&#125;</span>年，双11<span class="hljs-subst">$&#123;goodsName&#125;</span>促销倒计时：<span class="hljs-variable">$hour</span> 小时&quot;</span><br>   	 &#125;<br>  	<span class="hljs-comment">//简写以后 示例2</span><br>  	showOnBoard &#123; goodsName: String, hour: <span class="hljs-built_in">Int</span> -&gt;<br>     		<span class="hljs-keyword">val</span> currentYear = <span class="hljs-number">2022</span><br>             <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;currentYear&#125;</span>年，双11<span class="hljs-subst">$&#123;goodsName&#125;</span>促销倒计时：<span class="hljs-variable">$hour</span> 小时&quot;</span><br>   	 &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">showOnBoard</span><span class="hljs-params">(goodsName : <span class="hljs-type">String</span>, getDiscountWords : (<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">String</span>)</span></span>&#123;<br>  	<span class="hljs-comment">// shuffled 乱序</span><br>  	<span class="hljs-keyword">val</span> hour = (<span class="hljs-number">1.</span><span class="hljs-number">.24</span>).shuffled().last()<br>  	println(getDiscountWords(goodsName, hour))<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>lambda 与 函数类型的对象一样，在 JVM 上以对象实例的形式存在，JVM 会为所有同lambda打交道的变量分配内存，这就产生了内存开销，所以会造成性能问题。 幸运的是kotlin有一种优化机制叫内联，哪里需要lambda，编译器就会将函数复制粘贴到哪里（减少对象的创建）。</p>
<p>使用lambda的递归函数无法内联，因为会导致复制粘贴无限循环，编译器会发出警告。</p>
</blockquote>
<h3 id="函数引用"><a href="#函数引用" class="headerlink" title="函数引用"></a>函数引用</h3><p>要把函数作为参数给其它函数使用，除了传lambda表达式，还可以传递<strong>函数引用</strong>，函数引用可以把一个具名函数转换成一个穿参，也就是上文说的转换成函数类型的对象，使用的时候需要用<code>::method</code>引用。使用labmda表达式的地方，都可以使用函数引用。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  	showOnBoard(<span class="hljs-string">&quot;卫生纸&quot;</span>, ::getDiscountWords)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getDiscountWords</span><span class="hljs-params">(goodsName: <span class="hljs-type">String</span>, hour: <span class="hljs-type">Inte</span>)</span></span> : String&#123;<br>     	<span class="hljs-keyword">val</span> currentYear = <span class="hljs-number">2022</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;currentYear&#125;</span>年，双11<span class="hljs-subst">$&#123;goodsName&#125;</span>促销倒计时：<span class="hljs-variable">$hour</span> 小时&quot;</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">showOnBoard</span><span class="hljs-params">(goodsName : <span class="hljs-type">String</span>, getDiscountWords : (<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">String</span>)</span></span>&#123;<br>  	<span class="hljs-comment">// shuffled 乱序</span><br>  	<span class="hljs-keyword">val</span> hour = (<span class="hljs-number">1.</span><span class="hljs-number">.24</span>).shuffled().last()<br>  	println(getDiscountWords(goodsName, hour))<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="返回函数类型"><a href="#返回函数类型" class="headerlink" title="返回函数类型"></a>返回函数类型</h3><p>函数类型也是有效的返回类型，也就是说可以定义一个能返回函数的函数。</p>
<p><code>() :</code> 后面是返回值类型，感觉有点乱，怕忘了。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  	<span class="hljs-keyword">var</span> getDiscountWords = configDiscountWords()<br>  	println(getDiscountWords(<span class="hljs-string">&quot;沐浴露&quot;</span>))<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">configDiscountWords</span><span class="hljs-params">()</span></span> : (String) -&gt; String&#123;<br>  	<span class="hljs-keyword">val</span> currentYear = <span class="hljs-number">2022</span><br>  	<span class="hljs-keyword">val</span> hour = (<span class="hljs-number">1.</span><span class="hljs-number">.24</span>).shuffled().last()<br>  	<span class="hljs-keyword">return</span> &#123;goodsName : String -&gt; <br>  		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;currentYear&#125;</span>年，双11<span class="hljs-subst">$&#123;goodsName&#125;</span>促销倒计时：<span class="hljs-variable">$hour</span> 小时&quot;</span><br>   	 &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="2-闭包、lambda"><a href="#2-闭包、lambda" class="headerlink" title="2 闭包、lambda"></a>2 闭包、lambda</h2><blockquote>
<p>闭包 （为了避免变量名、方法名等等冲突，限定一个使用范围，类似java的package、class作用）</p>
<p>在Kotlin中，匿名函数能修改并引用定义在自己作用域之外的变量，匿名函数可以引用<strong>定义自身</strong>的函数里面的变量，Kotlin中的lambda就是闭包。</p>
<p>能接收函数或者返回函数的函数又叫做高级函数（也没啥高级的…，只是名字），高级函数广泛应用于函数时编程当中。</p>
</blockquote>
<p>为什么要在代码中使用函数类型？</p>
<blockquote>
<p>函数类型能让开发者少写模式化代码，（举个例子就是通过Interface传递函数，内部定义方法，对比kotlin多了个interface，比如OnClickListener）写出更灵活的代码。java8支持面向对象编程和lambda表达式，单不支持将函数作为参数传给另一个函数或变量，不过java实现方案是匿名内部类(也就是接口 + 匿名内部类实现 + 传递interface)。</p>
</blockquote>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>androidX下懒加载实现</title>
    <url>/2022/01/05/androidx-lazyload/</url>
    <content><![CDATA[<p>setMaxLifycycle代替onVisiable实现懒加载。</p>
<span id="more"></span>

<p>以前处理 Fragment 的懒加载，我们通常会在 Fragment 中处理 <code>setUserVisibleHint + onHiddenChanged</code> 这两个函数，而在 Androidx 模式下，我们可以使用 <code>FragmentTransaction.setMaxLifecycle()</code> 的方式来处理 Fragment 的懒加载。</p>
<p>在本文章中，我会详细介绍不同使用场景下两种方案的差异。大家快拿好小板凳。一起来学习新知识吧！</p>
<blockquote>
<p>本篇文章涉及到的 Demo，已上传至Github—-&gt;<a href="https://github.com/AndyJennifer/AndroidxLazyLoad">传送门</a></p>
</blockquote>
<h2 id="1-老的懒加载处理方案"><a href="#1-老的懒加载处理方案" class="headerlink" title="1 老的懒加载处理方案"></a>1 老的懒加载处理方案</h2><blockquote>
<p>如果你熟悉老一套的 Fragment 懒加载机制，你可以直接查看 Androix 懒加载相关章节</p>
</blockquote>
<h4 id="add-show-hide-模式下的老方案"><a href="#add-show-hide-模式下的老方案" class="headerlink" title="add+show+hide 模式下的老方案"></a>add+show+hide 模式下的老方案</h4><p>在没有添加懒加载之前，只要使用 <code>add+show+hide</code> 的方式控制并显示 Fragment, 那么不管 Fragment 是否嵌套，在初始化后，如果<code>只调用了add+show</code>，同级下的 Fragment 的相关生命周期函数都会被调用。且调用的生命周期函数如下所示：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">onAttach</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">onCreate</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">onCreatedView</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">onActivityCreated</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">onStart</span> -&gt;</span> onResume<br></code></pre></td></tr></table></figure>

<blockquote>
<p>Fragment 完整生命周期：onAttach -&gt; onCreate -&gt; onCreatedView -&gt; onActivityCreated -&gt; onStart -&gt; onResume -&gt; onPause -&gt; onStop -&gt; onDestroyView -&gt; onDestroy -&gt; onDetach</p>
</blockquote>
<p>什么是同级 Frament 呢？看下图</p>
<p><img  src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/19/16fb96781bfcafeb~tplv-t2oaga2asx-watermark.awebp"  ><span class="image-caption">同级Fragment.jpg</span></p>
<blockquote>
<p>上图中，都是使用 <code>add+show+hide</code> 的方式控制 Fragment,</p>
</blockquote>
<p>在上图两种模式中:</p>
<ul>
<li>Fragment_1、Fragment_2、Fragment_3 属于同级 Fragment</li>
<li>Fragment_a、Fragment_b、Fragment_c 属于同级 Fragment</li>
<li>Fragment_d、Fragment_e、Fragment_f 属于同级 Fragment</li>
</ul>
<p>那这种方式会带来什么问题呢？结合下图我们来分别分析。</p>
<p><img  src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/19/16fb967909b892db~tplv-t2oaga2asx-watermark.awebp"  ><span class="image-caption">show1.png</span></p>
<p>观察上图我们可以发现，同级的Fragment_1、Fragment_2、Fragment_3 都调用了 <code>onAttach...onResume</code> 系列方法，也就是说，如果我们没有对 Fragment 进行懒加载处理，那么我们就会无缘无故的加载一些并<code>不可见</code>的 Fragment , 也就会造成用户流量的无故消耗（我们会在 Fragment 相关生命周期函数中，请求网络或其他数据操作）。</p>
<blockquote>
<p>这里<code>&quot;不可见的Fragment&quot;</code>是指，实际不可见但是相关可见生命周期函数(如 <code>onResume</code> 方法）被调用的 Fragment</p>
</blockquote>
<p>如果使用嵌套 Fragment ，这种浪费流量的行为就更明显了。以本节的图一为例，当 Fragment_1 加载时，如果你在 Fragment_1 生命周期函数中使用 <code>show+add+hide</code> 的方式添加 <code>Fragment_a、Fragment_b、Fragment_c</code> , 那么 Fragment_b 又会在其生命周期函数中继续加载 <code>Fragment_d、Fragment_e、Fragment_f</code> 。</p>
<p>那如何解决这种问题呢？我们继续接着上面的例子走，当我们 <code>show Fragment_2</code>，并 hide其他 Fragment 时，对应 Fragment 的生命周期调用如下：</p>
<p><img  src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/19/16fb96782a90b81e~tplv-t2oaga2asx-watermark.awebp"  ><span class="image-caption">show2.png</span></p>
<p>从上图中，我们可以看出 Fragment_2 与 Fragment_3 都调用了 <code>onHiddenChanged</code> 函数，该函数的官方 API 声明如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Called when the hidden state (as returned by &#123;<span class="hljs-doctag">@link</span> #isHidden()&#125; of</span><br><span class="hljs-comment"> * the fragment has changed.  Fragments start out not hidden; this will</span><br><span class="hljs-comment"> * be called whenever the fragment changes state from that.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> hidden True if the fragment is now hidden, false otherwise.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onHiddenChanged</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> hidden)</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>根据官方 API 的注释，我们大概能知道，当 Fragment 隐藏的状态发生改变时，该函数将会被调用，如果当前 Fragment 隐藏， <code>hidden</code> 的值为 true, 反之为 false。最为重要的是<code>hidden</code> 的值，可以通过调用 <code>isHidden()</code> 函数获取。</p>
<p>那么结合上述知识点，我们能推导出：</p>
<ul>
<li>因为 Fragment_1 的 <code>隐藏状态</code> 从<code>可见转为了不可见</code>，所以其 <code>onHiddenChanged</code> 函数被调用，同时 <code>hidden</code> 的值为 true。</li>
<li>同理对于 Fragment_2 ，因为其 <code>隐藏状态</code> 从 <code>不可见转为了可见</code> ，所以其 hidden 值为 false。</li>
<li>对于 Fragment_3 ,因为其隐藏状态从始至终都没有发生变化，所以其 onHiddenChanged 函数并不会调用。</li>
</ul>
<p>嗯，好像有点眉目了。不急，我们继续看下面的例子。</p>
<p>show Fragment_3 并 hide 其他 Fragment ，对应生命周期函数调用如下所示：</p>
<p><img  src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/19/16fb967928f23799~tplv-t2oaga2asx-watermark.awebp"  ><span class="image-caption">show3.png</span></p>
<p>从图中，我们可以看出，确实只有<code>隐藏状态</code>发生了改变的 Fragment 其 <code>onHiddenChanged</code> 函数才会调用，那么结合以上知识点，我们能得出如下重要结论：</p>
<p><strong>只要通过 <code>show+hide</code> 方式控制 Fragment 的显隐，那么在第一次初始化后，Fragment 任何的生命周期方法都不会调用，只有 <code>onHiddenChanged</code> 方法会被调用。</strong></p>
<p>那么，假如我们要在 <code>add+show+hide</code> 模式下控制 Fragment 的懒加载，我们只需要做这两步：</p>
<ul>
<li>我们需要在 <code>onResume()</code> 函数中调用 <code>isHidden()</code> 函数，来处理默认显示的 Fragment</li>
<li>在 <code>onHiddenChanged</code> 函数中控制其他不可见的Fragment，</li>
</ul>
<p>也就是这样处理：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyFragment</span>:<span class="hljs-type">Fragment</span></span>()&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> isLoaded = <span class="hljs-literal">false</span> <span class="hljs-comment">//控制是否执行懒加载</span><br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onResume</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onResume()<br>        judgeLazyInit()<br><br>    &#125;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onHiddenChanged</span><span class="hljs-params">(hidden: <span class="hljs-type">Boolean</span>)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onHiddenChanged(hidden)<br>        isVisibleToUser = !hidden<br>        judgeLazyInit()<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">judgeLazyInit</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">if</span> (!isLoaded &amp;&amp; !isHidden) &#123;<br>            lazyInit()<br>            isLoaded = <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br><br>     <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDestroyView</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onDestroyView()<br>        isLoaded = <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-comment">//懒加载方法</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">lazyInit</span><span class="hljs-params">()</span></span><br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>该懒加载的实现，是在 <code>onResume</code> 方法中操作，当然你可以在其他生命周期函数中控制。但是建议在该方法中执行懒加载。</p>
</blockquote>
<h4 id="ViewPager-Fragment-模式下的老方案"><a href="#ViewPager-Fragment-模式下的老方案" class="headerlink" title="ViewPager+Fragment 模式下的老方案"></a>ViewPager+Fragment 模式下的老方案</h4><p>使用传统方式处理 ViewPager 中 Fragment 的懒加载，我们需要控制 <code>setUserVisibleHint(boolean isVisibleToUser)</code> 函数，该函数的声明如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUserVisibleHint</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> isVisibleToUser)</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure>

<p>该函数与之前我们介绍的 <code>onHiddenChanged()</code> 作用非常相似，都是通过传入的参数值来判断当前 Fragment 是否对用户可见，只是 <code>onHiddenChanged()</code> 是在 <code>add+show+hide</code> 模式下使用，而 <code>setUserVisibleHint</code> 是在 ViewPager+Fragment 模式下使用。</p>
<p>在本节中，我们用 <code>FragmentPagerAdapter + ViewPager</code> 为例，向大家讲解如何实现 Fragment 的懒加载。</p>
<blockquote>
<p>注意：在本例中没有调用 <code>setOffscreenPageLimit</code> 方法去设置 ViewPager 预缓存的 Fragment 个数。默认情况下 ViewPager 预缓存 Fragment 的个数为 <code>1</code> 。</p>
</blockquote>
<p>初始化 ViewPager 查看内部 Fragment 生命周期函数调用情况：</p>
<p><img  src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/19/16fb967817311da1~tplv-t2oaga2asx-watermark.awebp"  ><span class="image-caption">viewpager1.png</span></p>
<p>观察上图，我们能发现 ViePager 初始化时，默认会调用其内部 Fragment 的 setUserVisibleHint 方法，因为其预缓存 Fragment 个数为 <code>1</code> 的原因，所以只有 Fragment_1 与 Fragment_2 的生命周期函数被调用。</p>
<p>我们继续切换到 Fragment_2，查看各个Fragment的生命周期函数的调用变化。如下图所示：</p>
<p><img  src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/19/16fb967825d4acb4~tplv-t2oaga2asx-watermark.awebp"  ><span class="image-caption">viewpage2.png</span></p>
<p>观察上图，我们同样发现 Fragment 的 setUserVisibleHint 方法被调用了，并且 Fragment_3 的一系列生命周期函数被调用了。继续切换到 Fragment_3:</p>
<p><img  src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/19/16fb9679081837f2~tplv-t2oaga2asx-watermark.awebp"  ><span class="image-caption">viewpager_3.png</span></p>
<p>观察上图可以发现，Fragment_3 调用了 setUserVisibleHint 方法，继续又切换到 Fragment_1，查看调用函数的变化：</p>
<p><img  src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/19/16fb96782048236e~tplv-t2oaga2asx-watermark.awebp"  ><span class="image-caption">viewpager4.png</span></p>
<blockquote>
<p>因为之前在切换到 Fragment_3 时，Frafgment_1 已经走了 onDestoryView(图二，蓝色标记处) 方法，所以 Fragment_1 需要重新走一次生命周期。</p>
</blockquote>
<p>那么结合本节的三幅图，我们能得出以下结论：</p>
<ul>
<li>使用 ViewPager，切换回上一个 Fragment 页面时（已经初始化完毕），不会回调任何生命周期方法以及onHiddenChanged()，只有 setUserVisibleHint(boolean isVisibleToUser) 会被回调。</li>
<li>setUserVisibleHint(boolean isVisibleToUser) 方法总是会优先于 Fragment 生命周期函数的调用。</li>
</ul>
<p>所以如果我们想对 ViewPager 中的 Fragment 懒加载，我们需要这样处理：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyFragment</span> : <span class="hljs-type">Fragment</span></span>() &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 是否执行懒加载</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> isLoaded = <span class="hljs-literal">false</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当前Fragment是否对用户可见</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> isVisibleToUser = <span class="hljs-literal">false</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当使用ViewPager+Fragment形式会调用该方法时，setUserVisibleHint会优先Fragment生命周期函数调用，</span><br><span class="hljs-comment">     * 所以这个时候就,会导致在setUserVisibleHint方法执行时就执行了懒加载，</span><br><span class="hljs-comment">     * 而不是在onResume方法实际调用的时候执行懒加载。所以需要这个变量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> isCallResume = <span class="hljs-literal">false</span><br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onResume</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onResume()<br>        isCallResume = <span class="hljs-literal">true</span><br>        judgeLazyInit()<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">judgeLazyInit</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">if</span> (!isLoaded &amp;&amp; isVisibleToUser &amp;&amp; isCallResume) &#123;<br>            lazyInit()<br>            Log.d(TAG, <span class="hljs-string">&quot;lazyInit:!!!!!!!&quot;</span>)<br>            isLoaded = <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onHiddenChanged</span><span class="hljs-params">(hidden: <span class="hljs-type">Boolean</span>)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onHiddenChanged(hidden)<br>        isVisibleToUser = !hidden<br>        judgeLazyInit()<br>    &#125;<br><br>    <span class="hljs-comment">//在Fragment销毁View的时候，重置状态</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDestroyView</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onDestroyView()<br>        isLoaded = <span class="hljs-literal">false</span><br>        isVisibleToUser = <span class="hljs-literal">false</span><br>        isCallResume = <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setUserVisibleHint</span><span class="hljs-params">(isVisibleToUser: <span class="hljs-type">Boolean</span>)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.setUserVisibleHint(isVisibleToUser)<br>        <span class="hljs-keyword">this</span>.isVisibleToUser = isVisibleToUser<br>        judgeLazyInit()<br>    &#125;<br><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">lazyInit</span><span class="hljs-params">()</span></span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="复杂-Fragment-嵌套的情况"><a href="#复杂-Fragment-嵌套的情况" class="headerlink" title="复杂 Fragment 嵌套的情况"></a>复杂 Fragment 嵌套的情况</h4><p>当然，在实际项目中，我们可能会遇到更为复杂的 Fragment 嵌套组合。比如 Fragment+Fragment、Fragment+ViewPager、ViewPager+ViewPager….等等。 如下图所示：</p>
<p><img  src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/19/16fb96784fdd764d~tplv-t2oaga2asx-watermark.awebp"  ><span class="image-caption">复杂嵌套Fragment.jpg</span></p>
<p>对于以上场景，我们就需要重写我们的懒加载，以支持不同嵌套组合模式下 Fragment 正确懒加载。我们需要将 LazyFragment 修改成如下这样：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyFragment</span> : <span class="hljs-type">Fragment</span></span>() &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 是否执行懒加载</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> isLoaded = <span class="hljs-literal">false</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当前Fragment是否对用户可见</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> isVisibleToUser = <span class="hljs-literal">false</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当使用ViewPager+Fragment形式会调用该方法时，setUserVisibleHint会优先Fragment生命周期函数调用，</span><br><span class="hljs-comment">     * 所以这个时候就,会导致在setUserVisibleHint方法执行时就执行了懒加载，</span><br><span class="hljs-comment">     * 而不是在onResume方法实际调用的时候执行懒加载。所以需要这个变量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> isCallResume = <span class="hljs-literal">false</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 是否调用了setUserVisibleHint方法。处理show+add+hide模式下，默认可见 Fragment 不调用</span><br><span class="hljs-comment">     * onHiddenChanged 方法，进而不执行懒加载方法的问题。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> isCallUserVisibleHint = <span class="hljs-literal">false</span><br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onResume</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onResume()<br>        isCallResume = <span class="hljs-literal">true</span><br>        <span class="hljs-keyword">if</span> (!isCallUserVisibleHint) isVisibleToUser = !isHidden<br>        judgeLazyInit()<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">judgeLazyInit</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">if</span> (!isLoaded &amp;&amp; isVisibleToUser &amp;&amp; isCallResume) &#123;<br>            lazyInit()<br>            Log.d(TAG, <span class="hljs-string">&quot;lazyInit:!!!!!!!&quot;</span>)<br>            isLoaded = <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onHiddenChanged</span><span class="hljs-params">(hidden: <span class="hljs-type">Boolean</span>)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onHiddenChanged(hidden)<br>        isVisibleToUser = !hidden<br>        judgeLazyInit()<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDestroyView</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onDestroyView()<br>        isLoaded = <span class="hljs-literal">false</span><br>        isVisibleToUser = <span class="hljs-literal">false</span><br>        isCallUserVisibleHint = <span class="hljs-literal">false</span><br>        isCallResume = <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setUserVisibleHint</span><span class="hljs-params">(isVisibleToUser: <span class="hljs-type">Boolean</span>)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.setUserVisibleHint(isVisibleToUser)<br>        <span class="hljs-keyword">this</span>.isVisibleToUser = isVisibleToUser<br>        isCallUserVisibleHint = <span class="hljs-literal">true</span><br>        judgeLazyInit()<br>    &#125;<br><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">lazyInit</span><span class="hljs-params">()</span></span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Androidx-下的懒加载"><a href="#Androidx-下的懒加载" class="headerlink" title="Androidx 下的懒加载"></a>Androidx 下的懒加载</h3><p>虽然之前的方案就能解决轻松的解决 Fragment 的懒加载，但这套方案有一个最大的弊端，<code>就是不可见的 Fragment 执行了 onResume() 方法</code>。onResume 方法设计的初衷，难道不是当前 Fragment 可以和用户进行交互吗？你他妈既不可见，又不能和用户进行交互，你执行 onResume 方法干嘛？</p>
<p>基于此问题，Google 在 Androidx 在 <code>FragmentTransaction</code> 中增加了 <code>setMaxLifecycle</code> 方法来控制 Fragment 所能调用的最大的生命周期函数。如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * Set a ceiling for the state of an active fragment in this FragmentManager. If fragment is</span><br><span class="hljs-comment">  * already above the received state, it will be forced down to the correct state.</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * &lt;p&gt;The fragment provided must currently be added to the FragmentManager to have it&#x27;s</span><br><span class="hljs-comment">  * Lifecycle state capped, or previously added as part of this transaction. The</span><br><span class="hljs-comment">  * &#123;<span class="hljs-doctag">@link</span> Lifecycle.State&#125; passed in must at least be &#123;<span class="hljs-doctag">@link</span> Lifecycle.State#CREATED&#125;, otherwise</span><br><span class="hljs-comment">  * an &#123;<span class="hljs-doctag">@link</span> IllegalArgumentException&#125; will be thrown.&lt;/p&gt;</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> fragment the fragment to have it&#x27;s state capped.</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> state the ceiling state for the fragment.</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@return</span> the same FragmentTransaction instance</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-meta">@NonNull</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> FragmentTransaction <span class="hljs-title">setMaxLifecycle</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Fragment fragment,</span></span><br><span class="hljs-params"><span class="hljs-function">         <span class="hljs-meta">@NonNull</span> Lifecycle.State state)</span> </span>&#123;<br>     addOp(<span class="hljs-keyword">new</span> Op(OP_SET_MAX_LIFECYCLE, fragment, state));<br>     <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br> &#125;<br></code></pre></td></tr></table></figure>

<p>根据官方的注释，我们能知道，该方法可以设置活跃状态下 Fragment 最大的状态，如果该 Fragment 超过了设置的最大状态，那么会强制将 Fragment 降级到正确的状态。</p>
<p>那如何使用该方法呢？我们先看该方法在 Androidx 模式下 ViewPager+Fragment 模式下的使用例子。</p>
<h4 id="ViewPager-Fragment-模式下的方案"><a href="#ViewPager-Fragment-模式下的方案" class="headerlink" title="ViewPager+Fragment 模式下的方案"></a>ViewPager+Fragment 模式下的方案</h4><p>在 FragmentPagerAdapter 与 FragmentStatePagerAdapter 新增了含有  <code>behavior</code> 字段的构造函数，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FragmentPagerAdapter</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> FragmentManager fm,</span></span><br><span class="hljs-params"><span class="hljs-function">          <span class="hljs-meta">@Behavior</span> <span class="hljs-keyword">int</span> behavior)</span> </span>&#123;<br>      mFragmentManager = fm;<br>      mBehavior = behavior;<br>  &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FragmentStatePagerAdapter</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> FragmentManager fm,</span></span><br><span class="hljs-params"><span class="hljs-function">          <span class="hljs-meta">@Behavior</span> <span class="hljs-keyword">int</span> behavior)</span> </span>&#123;<br>      mFragmentManager = fm;<br>      mBehavior = behavior;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>其中 Behavior 的声明如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br> <span class="hljs-meta">@IntDef(&#123;BEHAVIOR_SET_USER_VISIBLE_HINT, BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT&#125;)</span><br> <span class="hljs-keyword">private</span> <span class="hljs-meta">@interface</span> Behavior &#123; &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * Indicates that &#123;<span class="hljs-doctag">@link</span> Fragment#setUserVisibleHint(boolean)&#125; will be called when the current</span><br><span class="hljs-comment">  * fragment changes.</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@deprecated</span> This behavior relies on the deprecated</span><br><span class="hljs-comment">  * &#123;<span class="hljs-doctag">@link</span> Fragment#setUserVisibleHint(boolean)&#125; API. Use</span><br><span class="hljs-comment">  * &#123;<span class="hljs-doctag">@link</span> #BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT&#125; to switch to its replacement,</span><br><span class="hljs-comment">  * &#123;<span class="hljs-doctag">@link</span> FragmentTransaction#setMaxLifecycle&#125;.</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@see</span> #FragmentPagerAdapter(FragmentManager, int)</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-meta">@Deprecated</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> BEHAVIOR_SET_USER_VISIBLE_HINT = <span class="hljs-number">0</span>;<br><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * Indicates that only the current fragment will be in the &#123;<span class="hljs-doctag">@link</span> Lifecycle.State#RESUMED&#125;</span><br><span class="hljs-comment">  * state. All other Fragments are capped at &#123;<span class="hljs-doctag">@link</span> Lifecycle.State#STARTED&#125;.</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@see</span> #FragmentPagerAdapter(FragmentManager, int)</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<p>从官方的注释声明中，我们能得到如下两条结论：</p>
<ul>
<li>如果 behavior 的值为 <code>BEHAVIOR_SET_USER_VISIBLE_HINT</code>，那么当 Fragment 对用户的可见状态发生改变时，<code>setUserVisibleHint</code> 方法会被调用。</li>
<li>如果 behavior 的值为 <code>BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT</code> ，那么当前选中的 Fragment 在 <code>Lifecycle.State#RESUMED</code> 状态 ，其他不可见的 Fragment 会被限制在 <code>Lifecycle.State#STARTED</code> 状态。</li>
</ul>
<p>那 BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT 这个值到底有什么作用呢？我们看下面的例子：</p>
<blockquote>
<p>在该例子中设置了 ViewPager 的适配器为 FragmentPagerAdapter 且 behavior 值为 <code>BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT</code>。</p>
</blockquote>
<p>默认初始化ViewPager，Fragment 生命周期如下所示：</p>
<p><img  src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/19/16fb967895238ac1~tplv-t2oaga2asx-watermark.awebp"  ><span class="image-caption">androix1.png</span></p>
<p>切换到 Fragment_2 时，日志情况如下所示：</p>
<p><img  src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/19/16fb96782b025a2f~tplv-t2oaga2asx-watermark.awebp"  ><span class="image-caption">androix2.png</span></p>
<p>切换到 Fragment_3 时，日志情况如下所示:</p>
<p><img  src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/19/16fb96788af81c73~tplv-t2oaga2asx-watermark.awebp"  ><span class="image-caption">androidx3.png</span></p>
<blockquote>
<p>因为篇幅的原因，本文没有在讲解 FragmentStatePagerAdapter 设置 behavior 下的使用情况，但是原理以及生命周期函数调用情况一样，感兴趣的小伙伴，可以根据  <a href="https://link.juejin.cn/?target=https://github.com/AndyJennifer/AndroidxLazyLoad">AndroidxLazyLoad</a> 项目自行测试。</p>
</blockquote>
<p>观察上述例子，我们可以发现，使用了 <code>BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT</code> 后，确实只有当前可见的 Fragment 调用了 onResume 方法。而导致产生这种改变的原因，是因为 FragmentPagerAdapter 在其 <code>setPrimaryItem</code> 方法中调用了 <code>setMaxLifecycle</code> 方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPrimaryItem</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> ViewGroup container, <span class="hljs-keyword">int</span> position, <span class="hljs-meta">@NonNull</span> Object object)</span> </span>&#123;<br>    Fragment fragment = (Fragment)object;<br>    <span class="hljs-comment">//如果当前的fragment不是当前选中并可见的Fragment,那么就会调用</span><br>    <span class="hljs-comment">// setMaxLifecycle 设置其最大生命周期为 Lifecycle.State.STARTED</span><br>    <span class="hljs-keyword">if</span> (fragment != mCurrentPrimaryItem) &#123;<br>        <span class="hljs-keyword">if</span> (mCurrentPrimaryItem != <span class="hljs-keyword">null</span>) &#123;<br>            mCurrentPrimaryItem.setMenuVisibility(<span class="hljs-keyword">false</span>);<br>            <span class="hljs-keyword">if</span> (mBehavior == BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT) &#123;<br>                <span class="hljs-keyword">if</span> (mCurTransaction == <span class="hljs-keyword">null</span>) &#123;<br>                    mCurTransaction = mFragmentManager.beginTransaction();<br>                &#125;<br>                mCurTransaction.setMaxLifecycle(mCurrentPrimaryItem, Lifecycle.State.STARTED);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                mCurrentPrimaryItem.setUserVisibleHint(<span class="hljs-keyword">false</span>);<br>            &#125;<br>        &#125;<br>    <span class="hljs-comment">//对于其他非可见的Fragment,则设置其最大生命周期为</span><br>    <span class="hljs-comment">//Lifecycle.State.RESUMED</span><br>        fragment.setMenuVisibility(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-keyword">if</span> (mBehavior == BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT) &#123;<br>            <span class="hljs-keyword">if</span> (mCurTransaction == <span class="hljs-keyword">null</span>) &#123;<br>                mCurTransaction = mFragmentManager.beginTransaction();<br>            &#125;<br>            mCurTransaction.setMaxLifecycle(fragment, Lifecycle.State.RESUMED);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            fragment.setUserVisibleHint(<span class="hljs-keyword">true</span>);<br>        &#125;<br><br>        mCurrentPrimaryItem = fragment;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>既然在上述条件下，只有实际可见的 Fragment 会调用 onResume 方法， 那是不是为我们提供了 ViewPager 下实现懒加载的新思路呢？也就是我们可以这样实现 Fragment 的懒加载：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyFragment</span> : <span class="hljs-type">Fragment</span></span>() &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> isLoaded = <span class="hljs-literal">false</span><br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onResume</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onResume()<br>        <span class="hljs-keyword">if</span> (!isLoaded) &#123;<br>            lazyInit()<br>            Log.d(TAG, <span class="hljs-string">&quot;lazyInit:!!!!!!!&quot;</span>)<br>            isLoaded = <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDestroyView</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onDestroyView()<br>        isLoaded = <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">lazyInit</span><span class="hljs-params">()</span></span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="add-show-hide-模式下的新方案"><a href="#add-show-hide-模式下的新方案" class="headerlink" title="add+show+hide 模式下的新方案"></a>add+show+hide 模式下的新方案</h4><p>虽然我们实现了Androidx 包下 ViewPager下的懒加载，但是我们仍然要考虑 add+show+hide 模式下的 Fragment 懒加载的情况，基于 ViewPager 在 <code>setPrimaryItem</code> 方法中的思路，我们可以在调用 add+show+hide 时，这样处理：</p>
<blockquote>
<p>完整的代码请点击—&gt;<a href="https://link.juejin.cn/?target=https://github.com/AndyJennifer/AndroidxLazyLoad/blob/master/app/src/main/java/com/jennifer/andy/androidxlazyload/ext/ShowHideExt.kt">ShowHideExt</a></p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用add+show+hide模式加载fragment</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 默认显示位置[showPosition]的Fragment，最大Lifecycle为Lifecycle.State.RESUMED</span><br><span class="hljs-comment"> * 其他隐藏的Fragment，最大Lifecycle为Lifecycle.State.STARTED</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *<span class="hljs-doctag">@param</span> containerViewId 容器id</span><br><span class="hljs-comment"> *<span class="hljs-doctag">@param</span> showPosition  fragments</span><br><span class="hljs-comment"> *<span class="hljs-doctag">@param</span> fragmentManager FragmentManager</span><br><span class="hljs-comment"> *<span class="hljs-doctag">@param</span> fragments  控制显示的Fragments</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadFragmentsTransaction</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-meta">@IdRes</span> containerViewId: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    showPosition: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    fragmentManager: <span class="hljs-type">FragmentManager</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">vararg</span> fragments: <span class="hljs-type">Fragment</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> (fragments.isNotEmpty()) &#123;<br>        fragmentManager.beginTransaction().apply &#123;<br>            <span class="hljs-keyword">for</span> (index <span class="hljs-keyword">in</span> fragments.indices) &#123;<br>                <span class="hljs-keyword">val</span> fragment = fragments[index]<br>                add(containerViewId, fragment, fragment.javaClass.name)<br>                <span class="hljs-keyword">if</span> (showPosition == index) &#123;<br>                    setMaxLifecycle(fragment, Lifecycle.State.RESUMED)<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    hide(fragment)<br>                    setMaxLifecycle(fragment, Lifecycle.State.STARTED)<br>                &#125;<br>            &#125;<br><br>        &#125;.commit()<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> IllegalStateException(<br>            <span class="hljs-string">&quot;fragments must not empty&quot;</span><br>        )<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/** 显示需要显示的Fragment[showFragment]，并设置其最大Lifecycle为Lifecycle.State.RESUMED。</span><br><span class="hljs-comment"> *  同时隐藏其他Fragment,并设置最大Lifecycle为Lifecycle.State.STARTED</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> fragmentManager</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> showFragment</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">showHideFragmentTransaction</span><span class="hljs-params">(fragmentManager: <span class="hljs-type">FragmentManager</span>, showFragment: <span class="hljs-type">Fragment</span>)</span></span> &#123;<br>    fragmentManager.beginTransaction().apply &#123;<br>        show(showFragment)<br>        setMaxLifecycle(showFragment, Lifecycle.State.RESUMED)<br><br>        <span class="hljs-comment">//获取其中所有的fragment,其他的fragment进行隐藏</span><br>        <span class="hljs-keyword">val</span> fragments = fragmentManager.fragments<br>        <span class="hljs-keyword">for</span> (fragment <span class="hljs-keyword">in</span> fragments) &#123;<br>            <span class="hljs-keyword">if</span> (fragment != showFragment) &#123;<br>                hide(fragment)<br>                setMaxLifecycle(fragment, Lifecycle.State.STARTED)<br>            &#125;<br>        &#125;<br>    &#125;.commit()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述代码的实现也非常简单：</p>
<ul>
<li>将需要显示的 Fragment ，在调用 add 或 show 方法后，<code>setMaxLifecycle(showFragment, Lifecycle.State.RESUMED)</code></li>
<li>将需要隐藏的 Fragment ，在调用 hide 方法后，<code>setMaxLifecycle(fragment, Lifecycle.State.STARTED)</code></li>
</ul>
<p>结合上述操作模式，查看使用 setMaxLifecycle 后，Fragment 生命周期函数调用的情况。</p>
<p>add Fragment_1、Fragment_2、Fragment_3，并 hide Fragment_2,Fragment_3 :</p>
<p><img  src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/19/16fb96794349c091~tplv-t2oaga2asx-watermark.awebp"  ><span class="image-caption">show_new1.png</span></p>
<p>show Fragment_2，hide 其他 Fragment:</p>
<p><img  src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/19/16fb9679260bc3e6~tplv-t2oaga2asx-watermark.awebp"  ><span class="image-caption">show_new2.png</span></p>
<p>show Fragment_3 hide 其他 Fragment:</p>
<p><img  src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/19/16fb967971fb39a5~tplv-t2oaga2asx-watermark.awebp"  ><span class="image-caption">show_new3.png</span></p>
<p>参考上图，好像真的也能处理懒加载！！！！！美滋滋</p>
<h5 id="并不完美的-setMaxLifecycle"><a href="#并不完美的-setMaxLifecycle" class="headerlink" title="并不完美的 setMaxLifecycle"></a>并不完美的 setMaxLifecycle</h5><p>当我第一次使用 setMaxLifycycle 方法时，我也和大家一样觉得万事大吉。但这套方案仍然有点点瑕疵，当 Fragment 的嵌套时，即使使用了 setMaxLifycycle 方法，第一次初始化时，同级不可见的Fragment，仍然 TMD 要调用可见生命周期方法。看下面的例子：</p>
<p><img  src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/19/16fb96794530f394~tplv-t2oaga2asx-watermark.awebp"  ><span class="image-caption">瑕疵.png</span></p>
<p>不知道是否是谷歌大大没有考虑到 Fragment 嵌套的情况，所以这里我们要对之前的方案就行修改，也就是如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyFragment</span> : <span class="hljs-type">Fragment</span></span>() &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> isLoaded = <span class="hljs-literal">false</span><br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onResume</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onResume()<br>        <span class="hljs-comment">//增加了Fragment是否可见的判断</span><br>        <span class="hljs-keyword">if</span> (!isLoaded &amp;&amp; !isHidden) &#123;<br>            lazyInit()<br>            Log.d(TAG, <span class="hljs-string">&quot;lazyInit:!!!!!!!&quot;</span>)<br>            isLoaded = <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDestroyView</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onDestroyView()<br>        isLoaded = <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">lazyInit</span><span class="hljs-params">()</span></span><br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上述代码中，因为同级的 Fragment 在嵌套模式下，仍然要调用 onResume 方法，所以我们增加了 Fragment 可见性的判断，这样就能保证嵌套模式下，新方案也能完美的支持 Fragment 的懒加载。</p>
<h5 id="ViewPager2-的处理方案"><a href="#ViewPager2-的处理方案" class="headerlink" title="ViewPager2 的处理方案"></a>ViewPager2 的处理方案</h5><p>ViewPager2 本身就支持对实际可见的 Fragment 才调用 onResume 方法。关于 ViewPager2 的内部机制。感兴趣的小伙伴可以自行查看源码。</p>
<p>关于 ViewPager2 的懒加载测试，已上传至 <a href="https://link.juejin.cn/?target=https://github.com/AndyJennifer/AndroidxLazyLoad">AndroidxLazyLoad</a>，大家可以结合项目查看Log日志。</p>
<h3 id="两种方式的对比与总结"><a href="#两种方式的对比与总结" class="headerlink" title="两种方式的对比与总结"></a>两种方式的对比与总结</h3><h4 id="老一套的懒加载"><a href="#老一套的懒加载" class="headerlink" title="老一套的懒加载"></a>老一套的懒加载</h4><ul>
<li>优点：不用去控制 FragmentManager的 add+show+hide 方法，所有的懒加载都是在Fragment 内部控制，也就是控制 <code>setUserVisibleHint + onHiddenChanged</code> 这两个函数。</li>
<li>缺点：实际不可见的 Fragment，其 <code>onResume</code> 方法任然会被调用，这种反常规的逻辑，无法容忍。</li>
</ul>
<h4 id="新一套的懒加载（Androidx下setMaxLifecycle）"><a href="#新一套的懒加载（Androidx下setMaxLifecycle）" class="headerlink" title="新一套的懒加载（Androidx下setMaxLifecycle）"></a>新一套的懒加载（Androidx下setMaxLifecycle）</h4><ul>
<li>优点：<code>在非特殊的情况下(缺点1)</code>，只有实际的可见 Fragment，其 <code>onResume</code> 方法才会被调用，这样才符合方法设计的初衷。</li>
<li>缺点：<ol>
<li>对于 Fragment 的嵌套，及时使用了 <code>setMaxLifecycle</code> 方法。同级不可见的Fragment， 仍然要调用 <code>onResume</code> 方法。</li>
<li>需要在原有的 add+show+hide 方法中，继续调用 setMaxLifecycle 方法来控制Fragment 的最大生命状态。</li>
</ol>
</li>
</ul>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>这两种方案的优缺点已经非常明显了，到底该选择何种懒加载模式，还是要基于大家的意愿，作者我更倾向于使用新的方案。关于 Fragment 的懒加载实现，非常愿意听到大家不同的声音，如果你有更好的方案，可以在评论区留下您的 idea，期待您的回复。如果您觉得本篇文章对你有所帮助，请不要吝啬你的关注与点赞。ღ( ´･ᴗ･` )比心</p>
<p>作者：AndyJennifer<br>链接：<a href="https://juejin.cn/post/6844904050698223624">https://juejin.cn/post/6844904050698223624</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<blockquote>
<p>以上为转载文章，以前onResume() 与 onVisiable() 某些情况用起来挺矛盾的，而且多层fragment的情况下onResume也会多次调用，还是比较推荐androidX下的方案的，当前项目内使用方法如下。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResume</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onResume();<br><br>    <span class="hljs-comment">// 使用懒加载</span><br>    <span class="hljs-keyword">if</span> (enableLazyData())<br>        onVisible();<br>&#125;<br><br><span class="hljs-comment">//默认不启用懒加载</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">enableLazyData</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><br><span class="hljs-comment">//懒加载实现</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onVisible</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (getLifecycle().getCurrentState() == Lifecycle.State.STARTED &amp;&amp; isFirst) &#123;<br>        <span class="hljs-comment">// 延迟加载 防止 切换动画还没执行完毕时数据就已经加载好了，这时页面会有渲染卡顿</span><br>        handler.postDelayed(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                initData();<br>                isFirst = <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;, <span class="hljs-number">300</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>懒加载</tag>
        <tag>androidx</tag>
      </tags>
  </entry>
  <entry>
    <title>MVVM 组件化实践</title>
    <url>/2022/01/06/android-component-based/</url>
    <content><![CDATA[<p>因为项目需要，本来计划用原来的模块化项目改造一下，改造一半发现之前写的架构用的东西太老了，而且有一些无用代码太老了，再加上刚好看到了一个Jetpack实践的项目，趁着java的余温，重新搭建一套吧，结合Jetpack，后续可能会改成kotlin。</p>
<h2 id="1-为什么使用组件化"><a href="#1-为什么使用组件化" class="headerlink" title="1 为什么使用组件化"></a>1 为什么使用组件化</h2><p>除了上述原因，但工程撸项目随着体积增大，越来越多的问题也开始体现（虽然确实快）</p>
<ul>
<li><strong>查找问题慢</strong>：定位问题，需要在多个代码混合的模块中寻找和跳转。</li>
<li><strong>开发维护成本增加</strong>：避免代码的改动影响其它业务的功能，导致开发和维护成本不断增加。</li>
<li><strong>编译时间长</strong>：项目工程越大，编译完整代码所花费的时间越长。</li>
<li><strong>开发效率低</strong>：多人协作开发时，开发风格不一，又很难将业务完全分割，大家互相影响，导致开发效率低下。</li>
<li><strong>代码复用性差</strong>：写过的代码很难抽离出来再次利用。</li>
</ul>
<h2 id="2-组件化优势"><a href="#2-组件化优势" class="headerlink" title="2 组件化优势"></a>2 组件化优势</h2><ul>
<li><strong>加快编译速度</strong>：每个业务功能都是一个单独的工程，可独立编译运行，拆分后代码量较少，编译自然变快。</li>
<li><strong>解耦</strong>：通过关注点分离的形式，将App分离成多个模块，每个模块都是一个组件。</li>
<li><strong>提高开发效率</strong>：多人开发中，每个组件模块由单人负责，降低了开发之间沟通的成本，减少因代码风格不一而产生的相互影响。</li>
<li><strong>代码复用</strong>：类似我们引用的第三方库，可以将基础组件或功能组件剥离。在新项目微调或直接使用。</li>
</ul>
<h2 id="3-组件分层"><a href="#3-组件分层" class="headerlink" title="3 组件分层"></a>3 组件分层</h2><p><img  src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49fe308e95ba4953a7495f283908d259~tplv-k3u1fbpfcp-watermark.awebp"  ><span class="image-caption">img</span></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin可空性判断</title>
    <url>/2022/01/06/kotlin-study-day3/</url>
    <content><![CDATA[<p>可空性判断与异常处理</p>
<span id="more"></span>

<h2 id="1-Kotlin可空性"><a href="#1-Kotlin可空性" class="headerlink" title="1 Kotlin可空性"></a>1 Kotlin可空性</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在Java中我们司空见惯的空指针异常NullPointerException，带给我们很多麻烦。Kotlin作为更强大的语言，势必会基于以往的语言设计对其进行改良。Kotlin更多的把运行时可能出现的null问题，以编译时错误的方式，<strong>提前在编译器强迫我们重视起来</strong>，而不是等运行时报错。</p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>对于null值问题，Kotlin反其道行之，除非另有规定，变量不可为null值。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//此代码报错</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">var</span> str:String = <span class="hljs-string">&quot;aXiang&quot;</span><br>    str = <span class="hljs-literal">null</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于可空类型，可使用<code>?</code>声明</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//此处不报错</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">var</span> str:String? = <span class="hljs-string">&quot;aXiang&quot;</span><br>    str = <span class="hljs-literal">null</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>声明时如果不直接赋值，可使用lateinit var声明，后续赋值.</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> view : View<br></code></pre></td></tr></table></figure>

<p>Kotlin区分可空类型和非可空类型，所以，要使一个可空类型变量运行，而它又可能不存在，对于这种潜在风险，编译器时刻警惕着。为了应对这种风险，Kotlin不允许在可空类型值上调用函数，除非<strong>手动接手安全管理</strong>。</p>
<h3 id="1、安全调用操作符"><a href="#1、安全调用操作符" class="headerlink" title="1、安全调用操作符"></a>1、安全调用操作符</h3><p>编译器看到有安全调用操作符，会知道如何检查null值，如果遇到null，它会跳过函数调用，而不是返回null。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">var</span> str:String? = <span class="hljs-string">&quot;aXiang&quot;</span><br>    str = <span class="hljs-literal">null</span><br>    println(str?.length)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2、使用带let的安全调用"><a href="#2、使用带let的安全调用" class="headerlink" title="2、使用带let的安全调用"></a>2、使用带let的安全调用</h3><p>安全调用允许在可空类型上调用函数，但是如果还想做点额外的事，比如创建新值，或判断不为null调用其他函数，可以使用带let函数的安全调用操作符。let的主要作用是让你在指定的作用域内定义一个活多个变量，与匿名函数一样，返回最后一行结果。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">var</span> str:String? = <span class="hljs-string">&quot;aXiang&quot;</span><br>    str = <span class="hljs-literal">null</span><br>    str?.let &#123; <br>        <span class="hljs-comment">// 非空字符串</span><br>        <span class="hljs-keyword">if</span> (it.isNotBlank())&#123;<br>            it.capitalize()<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-string">&quot;aXiang&quot;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3、非空断言操作符"><a href="#3、非空断言操作符" class="headerlink" title="3、非空断言操作符"></a>3、非空断言操作符</h3><p>!!又称感叹号操作符，当变量是null时，报出空指针异常。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">var</span> str:String? = <span class="hljs-string">&quot;aXiang&quot;</span><br>    str = <span class="hljs-literal">null</span><br>    println(str!!.capitalize())<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="4、使用if判断"><a href="#4、使用if判断" class="headerlink" title="4、使用if判断"></a>4、使用if判断</h3><p>与let相比，let更灵活，因为支持链式调用。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">var</span> str:String? = <span class="hljs-string">&quot;aXiang&quot;</span><br>    str = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">if</span> (str != <span class="hljs-literal">null</span>)&#123;<br>        str = str.capitalize()<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        println(<span class="hljs-string">&quot;null&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="5、使用空合并操作符"><a href="#5、使用空合并操作符" class="headerlink" title="5、使用空合并操作符"></a>5、使用空合并操作符</h3><p>如果 <code>?:</code> 前面的值非null，使用左边的值，是null，使用右边的值。</p>
<p>也可以搭配<code>let</code>使用代替<code>if/else</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">var</span> str:String? = <span class="hljs-string">&quot;aXiang&quot;</span><br>    str = <span class="hljs-literal">null</span><br>    println(str ?: <span class="hljs-string">&quot;peng&quot;</span>)<br>    println(str?.let &#123; it.capitalize() ?: <span class="hljs-string">&quot;peng&quot;</span> &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-异常处理"><a href="#2-异常处理" class="headerlink" title="2 异常处理"></a>2 异常处理</h2><h3 id="自定义处理"><a href="#自定义处理" class="headerlink" title="自定义处理"></a>自定义处理</h3><p>定义异常、抛出异常、处理异常</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">val</span> number: <span class="hljs-built_in">Int</span>? = <span class="hljs-literal">null</span><br>    checkOperation(number)<br>&#125;<br><span class="hljs-comment">//抛出异常</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">checkOperation</span><span class="hljs-params">(number: <span class="hljs-type">Int</span>?)</span></span>&#123;<br>    number ?: <span class="hljs-keyword">throw</span> UnskilledException()<br>&#125;<br><span class="hljs-comment">//定义异常</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnskilledException</span></span>() : IllegalArgumentException(<span class="hljs-string">&quot;操作不当&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>先决条件函数</p>
<p>Kotlin标注库提供了一些便利函数，使用这些内置函数，你可以抛出带自定义信息的异常。这些便利函数叫先决条件函数，你可以用它定义先决条件，条件必须满足，目标代码才能执行.</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">checkNotNull()<br>require()<br>requireNotNull()<br>assert()<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin字符串相关</title>
    <url>/2022/01/06/kotlin-study-day4/</url>
    <content><![CDATA[<p>字符串与数字类型</p>
<span id="more"></span>

<h2 id="1-字符串"><a href="#1-字符串" class="headerlink" title="1 字符串"></a>1 字符串</h2><h3 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h3><p>substring函数支持IntRange类型（表示一个整数范围的类型）的参数，until创建的范围不包括最后的值。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> Name = <span class="hljs-string">&quot;Jimmy&#x27;s friend&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">val</span> index = Name.indexOf(<span class="hljs-string">&quot;\&#x27;&quot;</span>)<br>    <span class="hljs-keyword">var</span> str = Name.substring(<span class="hljs-number">0</span> until index)<br>    println(str)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="拆分字符串"><a href="#拆分字符串" class="headerlink" title="拆分字符串"></a>拆分字符串</h3><p>split函数返回的是List集合数据，List集合又支持结构语法特性。也就是同时给多个变量赋值。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> NAMES = <span class="hljs-string">&quot;jackey,uzi,lwx&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> (origin,dest,proxy) = NAMES.split(<span class="hljs-string">&quot;,&quot;</span>)<br>    println(<span class="hljs-string">&quot;<span class="hljs-variable">$origin</span> <span class="hljs-variable">$dest</span> <span class="hljs-variable">$proxy</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="替换字符串"><a href="#替换字符串" class="headerlink" title="替换字符串"></a>替换字符串</h3><p>可以通过匿名函数替换</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> str = <span class="hljs-string">&quot;The people&#x27;s Republic of china&quot;</span><br>    <span class="hljs-keyword">val</span> str2 = str.replace(Regex(<span class="hljs-string">&quot;[aeiou]&quot;</span>))&#123;<br>        <span class="hljs-keyword">when</span> (it.value)&#123;<br>            <span class="hljs-string">&quot;a&quot;</span> -&gt; <span class="hljs-string">&quot;1&quot;</span><br>            <span class="hljs-string">&quot;e&quot;</span> -&gt; <span class="hljs-string">&quot;2&quot;</span><br>            <span class="hljs-string">&quot;i&quot;</span> -&gt; <span class="hljs-string">&quot;3&quot;</span><br>            <span class="hljs-string">&quot;o&quot;</span> -&gt; <span class="hljs-string">&quot;4&quot;</span><br>            <span class="hljs-string">&quot;u&quot;</span> -&gt; <span class="hljs-string">&quot;5&quot;</span><br>            <span class="hljs-keyword">else</span> -&gt; it.value<br>        &#125;<br>    &#125;<br>    println(str)<br>    println(str2)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><p>使用 <code>==</code> 检查两个字符串中字符是否匹配，使用 <code>===</code> 检查两个变量是否指向内存堆上同一对象。</p>
<h3 id="字符串遍历"><a href="#字符串遍历" class="headerlink" title="字符串遍历"></a>字符串遍历</h3><p>使用<code>String.forEach&#123; it &#125;</code>方法。</p>
<h2 id="2-数字类型"><a href="#2-数字类型" class="headerlink" title="2 数字类型"></a>2 数字类型</h2><h3 id="安全转换函数"><a href="#安全转换函数" class="headerlink" title="安全转换函数"></a>安全转换函数</h3><p>kotlin提供安全转换，如 String 转换 Int 时，类型错误会抛出异常。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> number: <span class="hljs-built_in">Int</span> = <span class="hljs-string">&quot;5.22&quot;</span>.toInt()<br></code></pre></td></tr></table></figure>

<p>可使用Kotlin提供的 <code>toIntOrNull()</code>方法，类型错误会返回null，不抛出异常。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> number: <span class="hljs-built_in">Int</span>? = <span class="hljs-string">&quot;5.22&quot;</span>.toIntOrNull()<br></code></pre></td></tr></table></figure>

<h3 id="Double转换"><a href="#Double转换" class="headerlink" title="Double转换"></a>Double转换</h3><p>精度损失与四舍五入</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//精度损失 -&gt; 3</span><br>println(<span class="hljs-number">3.56666</span>.toInt())<br></code></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//四舍五入 -&gt; 4</span><br>println(<span class="hljs-number">3.56666</span>.roundToInt())<br></code></pre></td></tr></table></figure>

<p>格式化字符串：保留两位小数</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">println(<span class="hljs-string">&quot;%.2f&quot;</span>.format(<span class="hljs-number">3.566666</span>))<br></code></pre></td></tr></table></figure>





]]></content>
  </entry>
  <entry>
    <title>Kotlin集合</title>
    <url>/2022/01/10/kotlin-study-day6/</url>
    <content><![CDATA[<p>集合List相关</p>
<span id="more"></span>

<h2 id="1-集合"><a href="#1-集合" class="headerlink" title="1 集合"></a>1 集合</h2><p>集合可以方便你处理一组数据，也可以作为值参传给函数，和我们学过的其它变量类型一样，List、Set和Map类型的变量也分为两类，<strong>只读和可变</strong>。</p>
<h3 id="List创建和获取"><a href="#List创建和获取" class="headerlink" title="List创建和获取"></a>List创建和获取</h3><p>通过<code>listOf</code>创建list。</p>
<p><code>getOrElse</code>是一个<strong>安全索引取值函数</strong>，它需要两个参数，第一个是索引值，第二个是能提供默认值的lambda表达式，如果索引值不存在的话，可用来代替异常。</p>
<p><code>getOrNull</code>是Kotlin提供的另一个安全索引取值函数，它返回null异常，而不是抛出异常.</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 创建list</span><br>    <span class="hljs-keyword">val</span> list = listOf(<span class="hljs-string">&quot;Jason&quot;</span>, <span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-string">&quot;Jacky&quot;</span>)<br>    <span class="hljs-comment">// 普通获取元素</span><br>    <span class="hljs-keyword">val</span> element = list[<span class="hljs-number">3</span>]<br>    <span class="hljs-comment">// 空安全获取元素，越界返回Unknow</span><br>    <span class="hljs-keyword">val</span> element = list.getOrElse(<span class="hljs-number">3</span>)&#123;<span class="hljs-string">&quot;Unknow&quot;</span>&#125;<br>    <span class="hljs-comment">// 空安全获取元素，越界返回Unknow</span><br>    <span class="hljs-keyword">val</span> element = list.getOrNull(<span class="hljs-number">3</span>) ?: <span class="hljs-string">&quot;Unknow&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="可变列表"><a href="#可变列表" class="headerlink" title="可变列表"></a>可变列表</h3><p>在Kotlin中，支持内容修改的列表叫可变列表，要创建可变列表，可以使用<code>mutableListOf</code>函数。List还支持使用<code>toList</code>和<code>toMutableList</code>函数动态实现只读列表和可变列表的转换.</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 创建可变list</span><br>    <span class="hljs-keyword">val</span> mutableList = mutableListOf(<span class="hljs-string">&quot;Jason&quot;</span>, <span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-string">&quot;Jacky&quot;</span>)<br>    <span class="hljs-comment">// 添加元素</span><br>    mutableList.add(<span class="hljs-string">&quot;Jimmy&quot;</span>)<br>    <span class="hljs-comment">// 删除元素</span><br>    mutableList.remove(<span class="hljs-string">&quot;Jack&quot;</span>)<br>    <span class="hljs-comment">// 转为不可变</span><br>    mutableList.toList()<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="mutator函数"><a href="#mutator函数" class="headerlink" title="mutator函数"></a>mutator函数</h3><p>能修改可变列表的函数有一个统一的名字：mutator函数（<code>add</code>、<code>remove</code>等）</p>
<p>添加运算符与删除运算符</p>
<p>基于lambda表达式删除指定条件的元素.</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 创建可变list</span><br>    <span class="hljs-keyword">val</span> mutableList = mutableListOf(<span class="hljs-string">&quot;Jason&quot;</span>, <span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-string">&quot;Jacky&quot;</span>)<br>    <span class="hljs-comment">// 添加元素（运算符重载）</span><br>    mutableList += <span class="hljs-string">&quot;Jimmy&quot;</span><br>    <span class="hljs-comment">// 删除元素（运算符重载）</span><br>    mutableList -= <span class="hljs-string">&quot;Jason&quot;</span><br>    <span class="hljs-comment">// 删除指定条件元素</span><br>    mutableList.removeIf &#123; it.contains(<span class="hljs-string">&quot;Jack&quot;</span>) &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="集合遍历"><a href="#集合遍历" class="headerlink" title="集合遍历"></a>集合遍历</h3><p>for..in 遍历</p>
<p>forEach 遍历</p>
<p>forEachIndexed 遍历时要获取索引</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 创建list</span><br>    <span class="hljs-keyword">val</span> list = listOf(<span class="hljs-string">&quot;Jason&quot;</span>, <span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-string">&quot;Jacky&quot;</span>)<br>    <span class="hljs-comment">// for in 遍历</span><br>    <span class="hljs-keyword">for</span> (s <span class="hljs-keyword">in</span> list)&#123;<br>        println(s)<br>    &#125;<br>    <span class="hljs-comment">// forEach 遍历</span><br>    list.forEach &#123; <br>        println(it)<br>    &#125;<br>    <span class="hljs-comment">// 需要索引位置</span><br>    list.forEachIndexed &#123; index, s -&gt;  <br>        println(<span class="hljs-string">&quot;<span class="hljs-variable">$index</span>， <span class="hljs-variable">$s</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h3><p>通过<code>_</code>过滤不想要的元素</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 跳过某个值，使用 _ 代替</span><br><span class="hljs-keyword">val</span> (origin, _, proxy) = list<br></code></pre></td></tr></table></figure>

<h2 id="2-Set-集合"><a href="#2-Set-集合" class="headerlink" title="2 Set 集合"></a>2 Set 集合</h2><h3 id="创建与获取"><a href="#创建与获取" class="headerlink" title="创建与获取"></a>创建与获取</h3><p>通过setOf创建set集合，使用elementAt函数读取集合中的元素。</p>
<p>list允许重复元素，set不允许。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 创建set</span><br>    <span class="hljs-keyword">val</span> <span class="hljs-keyword">set</span> = setOf(<span class="hljs-string">&quot;Jason&quot;</span>, <span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-string">&quot;Jacky&quot;</span>)<br>    <span class="hljs-comment">// 获取元素</span><br>    <span class="hljs-keyword">val</span> element = <span class="hljs-keyword">set</span>.elementAt(<span class="hljs-number">2</span>)<br>    <span class="hljs-comment">// 空安全获取元素，越界返回Unknow</span><br>    <span class="hljs-keyword">val</span> element = <span class="hljs-keyword">set</span>.elementAtOrElse(<span class="hljs-number">3</span>)&#123;<span class="hljs-string">&quot;Unknow&quot;</span>&#125;<br>    <span class="hljs-comment">// 空安全获取元素，越界返回Unknow</span><br>    <span class="hljs-keyword">val</span> element = <span class="hljs-keyword">set</span>.elementAtOrNull(<span class="hljs-number">3</span>) ?: <span class="hljs-string">&quot;Unknow&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="可变set集合"><a href="#可变set集合" class="headerlink" title="可变set集合"></a>可变set集合</h3><p>添加修改与List一致。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 创建可变set</span><br>    <span class="hljs-keyword">val</span> mutableSet = mutableSetOf(<span class="hljs-string">&quot;Jason&quot;</span>, <span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-string">&quot;Jacky&quot;</span>)<br>    <span class="hljs-comment">// 添加元素</span><br>    mutableSet += <span class="hljs-string">&quot;jimmy&quot;</span><br>    mutableSet.add(<span class="hljs-string">&quot;Jimmy&quot;</span>)<br>    <span class="hljs-comment">//与List一致</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="集合转换"><a href="#集合转换" class="headerlink" title="集合转换"></a>集合转换</h3><p>把List转换为Set，去除重复元素。<code>toSet()</code>与<code>toList()</code></p>
<p><code>distinct()</code> 去重函数</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 去重步骤</span><br>    <span class="hljs-keyword">val</span> list = listOf(<span class="hljs-string">&quot;Jason&quot;</span>, <span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-string">&quot;Jacky&quot;</span>, <span class="hljs-string">&quot;Jack&quot;</span>).toSet().toList()<br>    <span class="hljs-comment">// 快捷函数去重</span><br>    <span class="hljs-keyword">val</span> list = listOf(<span class="hljs-string">&quot;Jason&quot;</span>, <span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-string">&quot;Jacky&quot;</span>, <span class="hljs-string">&quot;Jack&quot;</span>).distinct()<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-数组"><a href="#3-数组" class="headerlink" title="3 数组"></a>3 数组</h2><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><p><code>xxxOf()</code>方法创建，xxx表示类型。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//创建IntArray数组</span><br>    <span class="hljs-keyword">val</span> intArray = intArrayOf(<span class="hljs-number">10</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>)<br>    <span class="hljs-comment">//创建file数组</span><br>    <span class="hljs-keyword">val</span> fileArray = arrayOf(File(<span class="hljs-string">&quot;1&quot;</span>), File(<span class="hljs-string">&quot;2&quot;</span>), File(<span class="hljs-string">&quot;3&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="4-Map集合"><a href="#4-Map集合" class="headerlink" title="4 Map集合"></a>4 Map集合</h2><h3 id="map的创建"><a href="#map的创建" class="headerlink" title="map的创建"></a>map的创建</h3><p><code>to</code>看上去像关键字，但事实上，它是个省略了点号和参数的特殊函数，to函数将它左右两边的值转化成一对儿<code>Pair</code>.</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> map = mapOf(<span class="hljs-string">&quot;Jack&quot;</span> to <span class="hljs-number">20</span>, <span class="hljs-string">&quot;Jason&quot;</span> to <span class="hljs-number">18</span>, <span class="hljs-string">&quot;Jackey&quot;</span> to <span class="hljs-number">30</span>)<br>    <span class="hljs-comment">//或者</span><br>    <span class="hljs-keyword">val</span> map = mapOf(Pair(<span class="hljs-string">&quot;Jimmy&quot;</span>, <span class="hljs-number">20</span>), Pair(<span class="hljs-string">&quot;Jason&quot;</span>, <span class="hljs-number">19</span>))<br>    println(map)<br><br></code></pre></td></tr></table></figure>

<h3 id="读取map的值"><a href="#读取map的值" class="headerlink" title="读取map的值"></a>读取map的值</h3><ul>
<li>[]读取运算符，读取键对应的值，如果键不存在返回null</li>
<li>getValue，读取键对应的值，如果键不存在抛出异常</li>
<li>getOrElse，读取键对应的值，或者使用匿名函数返回默认值</li>
<li>getOrDefault，读取键对应的值，或者返回默认值.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> map = mapOf(<span class="hljs-string">&quot;Jack&quot;</span> to <span class="hljs-number">20</span>, <span class="hljs-string">&quot;Jason&quot;</span> to <span class="hljs-number">18</span>, <span class="hljs-string">&quot;Jackey&quot;</span> to <span class="hljs-number">30</span>)<br>    <br>    <span class="hljs-comment">//方式1</span><br>    println(map[<span class="hljs-string">&quot;Jack&quot;</span>])<br>    <span class="hljs-comment">//方式2</span><br>    println(map.getValue(<span class="hljs-string">&quot;Jack&quot;</span>))<br>    <span class="hljs-comment">//方式3</span><br>    println(map.getOrElse(<span class="hljs-string">&quot;Rose&quot;</span>)&#123;<span class="hljs-string">&quot;Unknow&quot;</span>&#125;)<br>    <span class="hljs-comment">//方式4</span><br>    println(map.getOrDefault(<span class="hljs-string">&quot;Rose&quot;</span>, <span class="hljs-number">0</span>))<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="map遍历"><a href="#map遍历" class="headerlink" title="map遍历"></a>map遍历</h3><p>直接使用默认<code>it</code>，或者定义<code>key,value</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//方式1</span><br>map.forEach &#123; <br>    println(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;it.key&#125;</span>, <span class="hljs-subst">$&#123;it.value&#125;</span>&quot;</span>)<br>&#125;<br><span class="hljs-comment">//方式2</span><br>map.forEach &#123; (key, value) -&gt;  <br>    println(<span class="hljs-string">&quot;<span class="hljs-variable">$key</span>, <span class="hljs-variable">$value</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="可变集合"><a href="#可变集合" class="headerlink" title="可变集合"></a>可变集合</h3><p>通过<code>mutableMapOf</code>创建可变的Map</p>
<p><code>getOrPut</code> 键值不存在，就添加并返回结果，否则就返回已有键对应的值。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> mutableMap = mutableMapOf(<span class="hljs-string">&quot;Jack&quot;</span> to <span class="hljs-number">20</span>, <span class="hljs-string">&quot;Jason&quot;</span> to <span class="hljs-number">18</span>, <span class="hljs-string">&quot;Jackey&quot;</span> to <span class="hljs-number">30</span>)<br>    <span class="hljs-comment">// 添加内容</span><br>    mutableMap += <span class="hljs-string">&quot;Jimmy&quot;</span> to <span class="hljs-number">30</span><br>    <span class="hljs-comment">// 添加内容</span><br>    mutableMap.put(<span class="hljs-string">&quot;Jimmy&quot;</span>, <span class="hljs-number">31</span>)<br>    <span class="hljs-comment">// 如果没有，添加内容。</span><br>    mutableMap.getOrPut(<span class="hljs-string">&quot;Rose&quot;</span>)&#123; <span class="hljs-number">18</span> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>标准库函数</title>
    <url>/2022/01/10/kotlin-study-day5/</url>
    <content><![CDATA[<p>标准库使用</p>
<span id="more"></span>

<h2 id="1-标准库函数使用"><a href="#1-标准库函数使用" class="headerlink" title="1 标准库函数使用"></a>1 标准库函数使用</h2><h3 id="apply函数"><a href="#apply函数" class="headerlink" title="apply函数"></a>apply函数</h3><p>可看作一个<strong>配置函数</strong>，你可以穿入一个接收者，然后调用一系列函数类配置它以便使用，如果提供lambda给apply函数执行，它会返回配置好的接受者。</p>
<p>如：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> file = File(<span class="hljs-string">&quot;/Users/axiang/Documents/意见反馈接口文档.md&quot;</span>)<br>    file.setReadable(<span class="hljs-literal">true</span>)<br>    file.setWritable(<span class="hljs-literal">true</span>)<br>    <br>    <span class="hljs-keyword">val</span> file2 = File(<span class="hljs-string">&quot;/Users/axiang/Documents/意见反馈接口文档.md&quot;</span>).apply &#123;<br>        <span class="hljs-comment">//函数内自动传入file，所有操作直接针对file，最后返回file。</span><br>        setReadable(<span class="hljs-literal">true</span>)<br>        setWritable(<span class="hljs-literal">true</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到，调用一个个函数类配置接受者时，变量名就省掉了，这是因为，在lambda表达式里，apply能让每个配置函数都作用于接受者，这种行为有时又叫做<strong>相关作用域</strong>，因为labmda表达式里的所有函数调用都是针对接收者的，或者说，它们是针对接受者的<strong>隐式调用</strong>。</p>
<h3 id="let函数"><a href="#let函数" class="headerlink" title="let函数"></a>let函数</h3><p><code>let</code>函数能使某个变量作用于其表达式里，让<code>it</code>关键字能引用它。</p>
<p><code>let</code>与<code>apply</code>比较，let会把接收者传给<code>lambda</code>，而<code>apply</code>什么都不传，匿名函数执行完，<code>apply</code>会返回当前接收者，<code>let</code>会返回<code>lambda</code>最后一行。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 使用let求集合内第一个数的平方值</span><br>    <span class="hljs-keyword">val</span> result = listOf(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>).first().let &#123; <br>        it * it<br>    &#125;<br>    println(result)<br>    <span class="hljs-comment">// 不使用let求集合内第一个数平方值</span><br>    <span class="hljs-keyword">val</span> firstElement = listOf(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>).first()<br>    <span class="hljs-keyword">val</span> result = firstElement * firstElement<br>    println(result)<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 有名字返回welcome, xxx, 没名字返回What&#x27;s your name</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">formatGreeting</span><span class="hljs-params">(guestName: <span class="hljs-type">String</span>?)</span></span> : String&#123;<br>    <span class="hljs-keyword">return</span> guestName?.let &#123; <span class="hljs-string">&quot;welcome, <span class="hljs-variable">$it</span>&quot;</span> &#125; ?: <span class="hljs-string">&quot;What&#x27;s your name?&quot;</span><br>&#125;<br><span class="hljs-comment">//等同于</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">formatGreeting</span><span class="hljs-params">(guestName: <span class="hljs-type">String</span>?)</span></span> : String&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (guestName != <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-string">&quot;welcome, <span class="hljs-variable">$guestName</span>&quot;</span><br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-string">&quot;What&#x27;s your name?&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="run函数"><a href="#run函数" class="headerlink" title="run函数"></a>run函数</h3><p>光看作用域行为，run和apply差不多，但与apply不同，run函数不返回接收者，run返回的是<code>lambda</code>的结果，也就是最后一行。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 判断文本是否包含某字段</span><br>    <span class="hljs-keyword">val</span> file = File(<span class="hljs-string">&quot;/Users/axiang/Documents/意见反馈接口文档.md&quot;</span>)<br>    <span class="hljs-keyword">val</span> result = file.run &#123; <br>        readText().contains(<span class="hljs-string">&quot;great&quot;</span>)<br>    &#125;<br>    println(result)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>run也能用来执行函数引用</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-string">&quot;The People&#x27;s Republic of China.&quot;</span><br>        .run &#123; ::isLong &#125;<br>        .run &#123; ::showMessage &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isLong</span><span class="hljs-params">(name: <span class="hljs-type">String</span>)</span></span>:<span class="hljs-built_in">Boolean</span> = name.length &gt; <span class="hljs-number">10</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">showMessage</span><span class="hljs-params">(isLong: <span class="hljs-type">Boolean</span>)</span></span>: String&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (isLong)&#123;<br>        <span class="hljs-string">&quot;Name is too long.&quot;</span><br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-string">&quot;please rename.&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="with函数"><a href="#with函数" class="headerlink" title="with函数"></a>with函数</h3><p>with函数是run的变体，他们的功能行为是一样的，但是with调用方式不同，调用with需要值参作为其第一个参数传入.</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-string">&quot;The People&#x27;s Republic of China.&quot;</span>.run &#123; <br>    length &gt;= <span class="hljs-number">10</span><br>&#125;<br>with(<span class="hljs-string">&quot;The People&#x27;s Republic of China.&quot;</span>)&#123;<br>    length &gt;= <span class="hljs-number">10</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="also函数"><a href="#also函数" class="headerlink" title="also函数"></a>also函数</h3><p>与let函数相似，和let一样，also也是把接收者作为值参传给lambda，但有一点不同，also返回接收者对象，而let返回lambda结果。因为这个差异，also尤其适合<strong>针对同一原始对象</strong>，利用副作用做事，既然also返回的是接收者对象，你就可以<strong>基于原始接收者对象执行额外的链式调用</strong>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> fileContents: List&lt;String&gt;<br>    File(<span class="hljs-string">&quot;/Users/axiang/Documents/意见反馈接口文档.md&quot;</span>)<br>        .also &#123;<br>            println(it.name)<br>        &#125;<br>        .also &#123;<br>            fileContents = it.readLines()<br>        &#125;<br>    println(fileContents)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="takeIf函数"><a href="#takeIf函数" class="headerlink" title="takeIf函数"></a>takeIf函数</h3><p>与其它标准函数不一样，takeIf函数需要判断lambda提供的条件表达式，给出true或false结果，如果判断结果是<code>true</code>，从<code>takeIf</code>函数返回接收者对象，如果是<code>false</code>，返回<code>null</code>。如果<strong>需要判断某个条件是否满足，再决定是否可以赋值变量或执行某个任务</strong>，takeIf就非常有用，概念上讲，takeIf函数类似于if语句，但他的优势是可以直接在对象实例上调用，避免了临时变量赋值的麻烦。</p>
<p><strong>如：只要这个文件存在并且可读，老子就输出它</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> result = File(<span class="hljs-string">&quot;/Users/axiang/Documents/意见反馈接口文档.md&quot;</span>)<br>        .takeIf &#123; it.canRead() &amp;&amp; it.exists() &#125;<br>        ?.readText()<br>    println(result)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="takeUnless"><a href="#takeUnless" class="headerlink" title="takeUnless"></a>takeUnless</h3><p><code>takeIf</code>的辅助函数，只有判断你给定的条件结果是false时，takeUnless才会返回原始接收者对象。<strong>与takeIf相反</strong>。</p>
<p><strong>如：老子就要读这个md，除非它不可见。</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//文件非不可见，才输出</span><br>    <span class="hljs-keyword">val</span> result = File(<span class="hljs-string">&quot;/Users/axiang/Documents/意见反馈接口文档.md&quot;</span>)<br>        .takeUnless &#123; it.isHidden &#125;<br>        ?.readText()<br>    println(result)<br>&#125;<br></code></pre></td></tr></table></figure>













]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>接口、泛型</title>
    <url>/2022/01/12/kotlin-study-day10/</url>
    <content><![CDATA[<p>接口与泛型</p>
<span id="more"></span>

<h2 id="1-接口"><a href="#1-接口" class="headerlink" title="1 接口"></a>1 接口</h2><h3 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h3><p>Kotlin规定所有的借口属性和函数实现都要使用<code>override</code>关键字，接口中定义的函数并不需要<code>open</code>关键字修饰，他们默认都是<code>open</code>的。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 定义接口</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Moveable</span></span>&#123;<br>    <span class="hljs-keyword">var</span> maxSpeed: <span class="hljs-built_in">Int</span><br>    <span class="hljs-keyword">var</span> wheels: <span class="hljs-built_in">Int</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">move</span><span class="hljs-params">(moveable: <span class="hljs-type">Moveable</span>)</span></span>: String<br>&#125;<br><span class="hljs-comment">//实现</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span></span>(_name:String, <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> maxSpeed: <span class="hljs-built_in">Int</span> = <span class="hljs-number">4</span>, <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> wheels: <span class="hljs-built_in">Int</span> = <span class="hljs-number">4</span>) : Moveable &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">move</span><span class="hljs-params">(moveable: <span class="hljs-type">Moveable</span>)</span></span>: String &#123;<br>        TODO(<span class="hljs-string">&quot;Not yet implemented&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>只要你愿意，你可以在接口里提供默认属性的getter方法和函数实现。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 定义接口</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Moveable</span></span>&#123;<br>    <span class="hljs-keyword">val</span> maxSpeed: <span class="hljs-built_in">Int</span><br>        <span class="hljs-keyword">get</span>() = (<span class="hljs-number">1.</span><span class="hljs-number">.500</span>).shuffled().last()<br>    <span class="hljs-keyword">var</span> wheels: <span class="hljs-built_in">Int</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">move</span><span class="hljs-params">(moveable: <span class="hljs-type">Moveable</span>)</span></span>: String<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>要定义一个抽象类，你需要在定义之前加上abstract关键字，除了具体的函数实现，抽象类也可以包含抽象函数 - 只有定义，没有函数实现。</p>
<p>继承多个类，使用 <code>,</code> 分割。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Gun</span></span>(<span class="hljs-keyword">val</span> range: <span class="hljs-built_in">Int</span>)&#123;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">pullTrigger</span><span class="hljs-params">()</span></span>: String<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AK47</span>: <span class="hljs-type">Gun</span></span>(<span class="hljs-number">500</span>)&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">pullTrigger</span><span class="hljs-params">()</span></span>: String &#123;<br>        TODO(<span class="hljs-string">&quot;Not yet implemented&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-泛型"><a href="#2-泛型" class="headerlink" title="2 泛型"></a>2 泛型</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>泛型类的构造函数可以接受任何类型。（ <code>T</code> ）</p>
<p>示例：</p>
<p>MagicBox类指定的泛型参数由放在一对<code>&lt;&gt;</code>里的字母 <code>T</code> 表示，T是个代表item类型的占位符。</p>
<p>MagicBox类接收任何类型的item作为主构造函数值 <code>(item: T)</code>，并将item值赋给同样是T类型的<code>subject</code>私有属性。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> box =  MagicBox(Boy(<span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-number">20</span>))<br>    <span class="hljs-keyword">val</span> box2 = MagicBox(Dog(<span class="hljs-number">20</span>))<br>&#125;<br><span class="hljs-comment">// 定义泛型类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MagicBox</span>&lt;<span class="hljs-type">T</span>&gt;</span>(item: T)&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> subject: T = item<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Boy</span></span>(<span class="hljs-keyword">val</span> name: String, <span class="hljs-keyword">val</span> age: <span class="hljs-built_in">Int</span>)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span></span>(<span class="hljs-keyword">val</span> weight: <span class="hljs-built_in">Int</span>)<br></code></pre></td></tr></table></figure>

<p><strong>Tip:</strong> 泛型参数常用字母T（代表英文type）表示，当然，想用其他字母，甚至是英文单词都是可以的。不过，其他支持泛型的语言都在用这个约定俗称的T，所以建议你继续用它，这样写出的代码更容易理解。</p>
<h3 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h3><ul>
<li>泛型参数也可以用于函数。</li>
<li>定义一个函数用于获取元素，并且仅当MagicBox可用时，才能获取元素。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MagicBox</span>&lt;<span class="hljs-type">T</span>&gt;</span>(item: T)&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> subject: T = item<br>    <span class="hljs-keyword">var</span> available = <span class="hljs-literal">false</span><br>    <br>    <span class="hljs-comment">// 泛型函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fetch</span><span class="hljs-params">()</span></span> : T?&#123;<br>        <span class="hljs-keyword">return</span> subject.takeIf &#123; available &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="多泛型参数"><a href="#多泛型参数" class="headerlink" title="多泛型参数"></a>多泛型参数</h3><p>泛型函数或泛型类也可以有多个泛型参数。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 定义泛型类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MagicBox</span>&lt;<span class="hljs-type">T</span>&gt;</span>(item: T)&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> subject: T = item<br>    <span class="hljs-keyword">var</span> available = <span class="hljs-literal">false</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R&gt;</span> <span class="hljs-title">fetch</span><span class="hljs-params">(subjectModFunction: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">R</span>)</span></span>: R? &#123;<br>        <span class="hljs-keyword">return</span> subjectModFunction(subject).takeIf &#123; available &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Boy</span></span>(<span class="hljs-keyword">val</span> name: String, <span class="hljs-keyword">val</span> age: <span class="hljs-built_in">Int</span>)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Man</span></span>(<span class="hljs-keyword">val</span> name: String, <span class="hljs-keyword">val</span> age: <span class="hljs-built_in">Int</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> box =  MagicBox(Boy(<span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-number">20</span>))<br>    box.fetch &#123; <br>        Man(it.name, it.age.plus(<span class="hljs-number">15</span>))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="泛型类型约束"><a href="#泛型类型约束" class="headerlink" title="泛型类型约束"></a>泛型类型约束</h3><p>如果要确保MagicBox里面只能装指定类型的物品，如Human类型，怎么办？</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 只接收Human类型或子类型</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MagicBox</span>&lt;<span class="hljs-type">T : Human</span>&gt;</span>(item: T)&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> subject: T = item<br>&#125;<br><br><span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Human</span></span>(<span class="hljs-keyword">open</span> <span class="hljs-keyword">val</span> age: <span class="hljs-built_in">Int</span>)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Boy</span></span>(<span class="hljs-keyword">val</span> name: String, <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> age: <span class="hljs-built_in">Int</span>) : Human(age)<br></code></pre></td></tr></table></figure>

<h3 id="vararg关键字和get函数"><a href="#vararg关键字和get函数" class="headerlink" title="vararg关键字和get函数"></a>vararg关键字和get函数</h3><p>MagicBox能存放任何类型的Human实例，但一次只能放一个，如果需要放入多个实例呢？</p>
<p>使用可变参数<code>vararg</code>，类似java的 <code>..</code>。</p>
<p>传入参数类型为 <code>Array&lt;out T&gt;</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 定义泛型类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MagicBox</span>&lt;<span class="hljs-type">T : Human</span>&gt;</span>(<span class="hljs-keyword">vararg</span> item: T)&#123;<br>    <span class="hljs-comment">// 接收可变参数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> subject: Array&lt;<span class="hljs-keyword">out</span> T&gt; = item<br>    <span class="hljs-comment">// 使用时取值</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fetch</span><span class="hljs-params">(index: <span class="hljs-type">Int</span>)</span></span>&#123;<br>        println(subject[index])<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> box =  MagicBox(Boy(<span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-number">20</span>), Boy(<span class="hljs-string">&quot;Jimmy&quot;</span>,<span class="hljs-number">3</span>))<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="操作符取值"><a href="#操作符取值" class="headerlink" title="[] 操作符取值"></a>[] 操作符取值</h3><p>想通过[]操作符取值，可以重载运算符函数<code>get</code>函数。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 定义泛型类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MagicBox</span>&lt;<span class="hljs-type">T : Human</span>&gt;</span>(<span class="hljs-keyword">vararg</span> item: T)&#123;<br>    <span class="hljs-comment">// 接收可变参数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> subject: Array&lt;<span class="hljs-keyword">out</span> T&gt; = item<br>    <span class="hljs-comment">// 重载 [] 方法</span><br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">get</span><span class="hljs-params">(index: <span class="hljs-type">Int</span>)</span></span> : T? = subject[index]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> box =  MagicBox(Boy(<span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-number">20</span>), Boy(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-number">3</span>))<br>    println(box[<span class="hljs-number">0</span>])<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="out协变"><a href="#out协变" class="headerlink" title="out协变"></a>out协变</h3><p>如果泛型类只将泛型类型作为函数的输出（返回），那么使用out，可以称之为生产类/接口，因为它主要是用来生产指定的泛型对象。</p>
<p><strong>此外，</strong>子类泛型对象可以赋值给父类泛型对象，也就是<code>out T</code>，可以传入其子类型。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Source</span>&lt;<span class="hljs-type">out T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">nextT</span><span class="hljs-params">()</span></span>: T<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">demo</span><span class="hljs-params">(strs: <span class="hljs-type">Source</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> objects: Source&lt;Any&gt; = strs <span class="hljs-comment">// 这个没问题，因为 T 是一个 out-参数</span><br>    <span class="hljs-comment">// ……</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="in逆变"><a href="#in逆变" class="headerlink" title="in逆变"></a>in逆变</h3><p>如果泛型类只将泛型类型作为函数的输入（入参），那么使用in，可以称之为消费者类/接口，因为它主要用来消费指定的泛型对象。</p>
<p><strong>此外，</strong>父类泛型对象可以赋值给子类泛型对象，也就是福类型可以传入 <code>in T</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-type">in T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(other: <span class="hljs-type">T</span>)</span></span>: <span class="hljs-built_in">Int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">demo</span><span class="hljs-params">(x: <span class="hljs-type">Comparable</span>&lt;<span class="hljs-type">Number</span>&gt;)</span></span> &#123;<br>    x.compareTo(<span class="hljs-number">1.0</span>) <span class="hljs-comment">// 1.0 拥有类型 Double，它是 Number 的子类型</span><br>    <span class="hljs-comment">// 因此，我们可以将 x 赋给类型为 Comparable &lt;Double&gt; 的变量</span><br>    <span class="hljs-keyword">val</span> y: Comparable&lt;<span class="hljs-built_in">Double</span>&gt; = x <span class="hljs-comment">// OK！</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="invariant不变"><a href="#invariant不变" class="headerlink" title="invariant不变"></a>invariant不变</h3><p>如果泛型类即将泛型类型作为函数入参，又将函数作为函数的输出，那么既不用out也不用in。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ProductionConsumer</span>&lt;<span class="hljs-type">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">product</span><span class="hljs-params">()</span></span> : T<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">consumer</span><span class="hljs-params">(item : <span class="hljs-type">T</span>)</span></span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="reified具体化"><a href="#reified具体化" class="headerlink" title="reified具体化"></a>reified具体化</h3><p>我们知道在java中使用泛型的时候，无法通过泛型来得到Class，一般我们会将Class通过参数传过去。</p>
<p>在kotlin中一个内联函数（<code>inline</code>）可以被具体化（<code>reified</code>），这意味着我们可以得到使用泛型类型的Class。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MagicBox</span>&lt;<span class="hljs-type">T : Human</span>&gt;</span>&#123;<br>    <span class="hljs-comment">// 随机产生一个对象，如果不是指定类型，通过backup函数生成一个</span><br>    <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T&gt;</span> <span class="hljs-title">randomOrBackup</span><span class="hljs-params">(backup: () -&gt; <span class="hljs-type">T</span>)</span></span> : T &#123;<br>        <span class="hljs-keyword">val</span> items = listOf(<br>            Boy(<span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-number">20</span>),<br>            Man(<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-number">45</span>)<br>        )<br>        <span class="hljs-comment">// 随机生成</span><br>        <span class="hljs-keyword">val</span> random = items.shuffled().first()<br>        <span class="hljs-comment">// 使用 reified 以后，可以得到class</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (random <span class="hljs-keyword">is</span> T)&#123;<br>            random<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            backup()<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Human</span></span>(<span class="hljs-keyword">open</span> <span class="hljs-keyword">val</span> age: <span class="hljs-built_in">Int</span>)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Boy</span></span>(<span class="hljs-keyword">val</span> name: String, age: <span class="hljs-built_in">Int</span>) : Human(age)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Man</span></span>(<span class="hljs-keyword">val</span> name: String, age: <span class="hljs-built_in">Int</span>) : Human(age)<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">val</span> box1: MagicBox&lt;Man&gt; = MagicBox()<br>    <span class="hljs-keyword">val</span> subject = box1.randomOrBackup &#123; <br>        Man(<span class="hljs-string">&quot;Jimmy&quot;</span>, <span class="hljs-number">20</span>)<br>    &#125;<br>    println(subject)<br>&#125;<br></code></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>扩展函数相关</title>
    <url>/2022/01/18/kotlin-study-day11/</url>
    <content><![CDATA[<p>扩展</p>
<span id="more"></span>

<h2 id="1-扩展"><a href="#1-扩展" class="headerlink" title="1 扩展"></a>1 扩展</h2><h3 id="定义扩展函数"><a href="#定义扩展函数" class="headerlink" title="定义扩展函数"></a>定义扩展函数</h3><p>扩展可以在<strong>不直接修改类定义的情况下增加类功能</strong>，扩展可以用于自定义类，也可以用于List、String，以及Kotlin标准库里的其他类。</p>
<p>与继承相似，扩展也能共享类行为，在你<strong>无法接触某个类定义，或者某个类没有使用open修饰符，导致你无法继承它时</strong>，扩展就是增加类功能的最好选择。</p>
<p>定义扩展函数与定义一般函数差不多，只是除了函数定义，需要指定接收功能扩展的接收者类型，如 <code>String.addExt</code>.</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//定义String扩展函数，给字符串追加若干个！</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">addExt</span><span class="hljs-params">(amount: <span class="hljs-type">Int</span> = <span class="hljs-number">2</span>)</span></span> = <span class="hljs-keyword">this</span> + <span class="hljs-string">&quot;!&quot;</span>.repeat(amount)<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    println(<span class="hljs-string">&quot;abc&quot;</span>.addExt(<span class="hljs-number">4</span>))<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="超类上定义扩展函数"><a href="#超类上定义扩展函数" class="headerlink" title="超类上定义扩展函数"></a>超类上定义扩展函数</h3><p>使用<code>Any.</code>定义</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> Any.<span class="hljs-title">easyPrint</span><span class="hljs-params">()</span></span> = println(<span class="hljs-keyword">this</span>)<br></code></pre></td></tr></table></figure>

<h3 id="泛型扩展函数"><a href="#泛型扩展函数" class="headerlink" title="泛型扩展函数"></a>泛型扩展函数</h3><p>新的泛型扩展函数不仅可以支持任何类型的接收者，还保留了接收者的类型信息，使用泛型类型后，扩展函数能够支持更多类型的接收者，适用范围更广了。</p>
<p><code>let</code>、<code>apply</code>等函数均为泛型扩展函数使用案例。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//定义String扩展函数，给字符串追加若干个！</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">addExt</span><span class="hljs-params">(amount: <span class="hljs-type">Int</span> = <span class="hljs-number">2</span>)</span></span> = <span class="hljs-keyword">this</span> + <span class="hljs-string">&quot;!&quot;</span>.repeat(amount)<br><span class="hljs-comment">//定义泛型扩展函数，返回接收者类型</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> T.<span class="hljs-title">easyPrint</span><span class="hljs-params">()</span></span> : T &#123;<br>    println(<span class="hljs-keyword">this</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-string">&quot;abc&quot;</span>.easyPrint().addExt(<span class="hljs-number">4</span>).easyPrint()<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="扩展属性"><a href="#扩展属性" class="headerlink" title="扩展属性"></a>扩展属性</h3><p>除了给类添加功能扩展函数外，你还可以给类定义扩展属性，给String类添加一个扩展，这个扩展属性可以统计字符串里有多少个元音字母。</p>
<h3 id="可空类扩展"><a href="#可空类扩展" class="headerlink" title="可空类扩展"></a>可空类扩展</h3><p>你也可以定义扩展函数用于可空类型，在可空类型上定义扩展函数，你就可以直接在扩展函数体内解决可能出现的空值问题。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 定义可空类型扩展函数，输入为空时返回输出默认字符串</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> String?.<span class="hljs-title">printWithDefault</span><span class="hljs-params">(default: <span class="hljs-type">String</span>)</span></span> = print(<span class="hljs-keyword">this</span> ?: default)<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">val</span> nullableString: String? = <span class="hljs-literal">null</span><br>    nullableString.printWithDefault(<span class="hljs-string">&quot;This is null&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="infix-关键字"><a href="#infix-关键字" class="headerlink" title="infix 关键字"></a>infix 关键字</h3><p>infix关键字适用于有单个参数的扩展和类函数，可以让你以更简洁的语法调用函数。</p>
<p>如果一个函数定义使用了<code>infix</code>关键字，那么调用它时，<strong>接收者和函数之间的点操作以及参数的一对括号都可以不要</strong>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 定义可空类型扩展函数，输入为空时返回输出默认字符串</span><br><span class="hljs-keyword">infix</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> String?.<span class="hljs-title">printWithDefault</span><span class="hljs-params">(default: <span class="hljs-type">String</span>)</span></span> = print(<span class="hljs-keyword">this</span> ?: default)<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">val</span> nullableString: String? = <span class="hljs-literal">null</span><br>    <span class="hljs-comment">// 与上面的不一致</span><br>    nullableString printWithDefault <span class="hljs-string">&quot;This is null&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="定义扩展文件"><a href="#定义扩展文件" class="headerlink" title="定义扩展文件"></a>定义扩展文件</h3><p>扩展函数需要再多个文件里面调用，可以将它们定义在单独的文件，然后用<code>import</code>。</p>
<p><strong>其实就是把扩展函数单独写在一块儿了</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> com.ren.kotlinstudyapplication.extension.randomTake<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">val</span> list = listOf(<span class="hljs-string">&quot;Jason&quot;</span>, <span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-string">&quot;Tom&quot;</span>)<br>    list.randomTake()<br></code></pre></td></tr></table></figure>

<h3 id="重命名扩展"><a href="#重命名扩展" class="headerlink" title="重命名扩展"></a>重命名扩展</h3><p>使用的扩展函数名称不和你的意，可以使用 as 修改。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> com.ren.kotlinstudyapplication.extension.randomTake <span class="hljs-keyword">as</span> randomizer<br></code></pre></td></tr></table></figure>

<h3 id="DSL"><a href="#DSL" class="headerlink" title="DSL"></a>DSL</h3><p>使用这样的编程范式，就可以写出业界知名的 <strong>领域特定语言</strong>（DSL），一种API编程范式，暴露接收者的函数和特性，以便于使用你定义的lambda表达式来读取和配置他们。</p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>类与构造函数</title>
    <url>/2022/01/11/kotlin-study-day7/</url>
    <content><![CDATA[<p>构造函数、初始化等</p>
<span id="more"></span>

<h2 id="1-定义类"><a href="#1-定义类" class="headerlink" title="1 定义类"></a>1 定义类</h2><h3 id="field"><a href="#field" class="headerlink" title="field"></a>field</h3><ul>
<li>针对你定义的每一个属性，Kotlin都会生成一个<code>field</code>（内容是对象本身）、一个<code>getter</code>、以及一个<code>setter</code>，field用来存储属性数据，你不能直接定义field，Kotlin会封装field，保护它里面的数据，只暴露给getter和setter使用。</li>
<li>属性的getter方法决定你如何读取属性值，每个属性都有getter方法，setter方法决定你如何给属性赋值，所以只有可变属性才会有setter方法，尽管Kotlin会自动提供默认的getter和setter方法，但在需要控制如何读写属性数据时，你也可以自定义它们。</li>
<li>get 和 set要紧跟属性，谁的方法就在谁下面。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">var</span> p = Player()<br>        <span class="hljs-comment">//此处调用name的set方法</span><br>        p.name = <span class="hljs-string">&quot;ros  e&quot;</span><br>        <span class="hljs-comment">//此处调用name的get方法</span><br>        println(p.name)<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Player</span></span>&#123;<br>    <span class="hljs-comment">// 声明变量自动生成set、get</span><br>    <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;jack&quot;</span><br>    <span class="hljs-keyword">get</span>() = field.capitalize()<br>    <span class="hljs-keyword">set</span>(value) &#123;<br>        field = value.trim()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>计算属性是通过一个覆盖的get或set运算符来定义，这是field就不需要了。（也就是不需要通过传入值判断返回什么）</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> rolledValue<br>    <span class="hljs-keyword">get</span>() = (<span class="hljs-number">1.</span><span class="hljs-number">.7</span>).shuffled().first()<br></code></pre></td></tr></table></figure>

<h3 id="防范竞态条件"><a href="#防范竞态条件" class="headerlink" title="防范竞态条件"></a>防范竞态条件</h3><p>如果一个类属性即可空又可变，那么引用它之前你必须保证它非空，一个办法是用also标准函数。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Player</span></span>&#123;<br>    <span class="hljs-keyword">var</span> words: String? = <span class="hljs-string">&quot;hello&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span>&#123;<br>        words?.also &#123;<br>            println(<span class="hljs-string">&quot;Hello <span class="hljs-subst">$&#123;it.toUpperCase()&#125;</span>&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2 构造函数"></a>2 构造函数</h2><h3 id="主构造函数"><a href="#主构造函数" class="headerlink" title="主构造函数"></a>主构造函数</h3><p>我们在Player类的定义头中定义一个主构造函数，使用临时变量为Player的各个属性提供初始值，在Kotlin中，为便于识别，临时变量（包括仅引用一次的参数），通常都会<strong>以下划线开头命名</strong>。</p>
<p>类名后面直接添加<code>()</code>，为构造函数。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">var</span> player = Player(<span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-literal">true</span>)<br>    println(player)<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Player</span></span>(<br>    _name:String,<br>    _age:<span class="hljs-built_in">Int</span>,<br>    _isNormal:<span class="hljs-built_in">Boolean</span><br>)&#123;<br>    <span class="hljs-keyword">var</span> name = _name<br>        <span class="hljs-keyword">get</span>() = field.capitalize()<br>        <span class="hljs-keyword">set</span>(value) &#123; field = value.trim() &#125;<br>    <span class="hljs-keyword">var</span> age = _age<br>    <span class="hljs-keyword">var</span> isNormal = _isNormal<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="在主构造函数里面定义属性"><a href="#在主构造函数里面定义属性" class="headerlink" title="在主构造函数里面定义属性"></a>在主构造函数里面定义属性</h3><p>kotlin允许你不使用临时变量赋值，而是直接用一个定义同时指定参数和类属性，通常，我们更喜欢用这种方法定义类属性，因为会减少重复代码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Player</span></span>(<br>    _name:String,<br>    <span class="hljs-keyword">var</span> age:<span class="hljs-built_in">Int</span>,<br>    <span class="hljs-keyword">var</span> sNormal:<span class="hljs-built_in">Boolean</span><br>)&#123;<br>    <span class="hljs-keyword">var</span> name = _name<br>        <span class="hljs-keyword">get</span>() = field.capitalize()<br>        <span class="hljs-keyword">set</span>(value) &#123; field = value.trim() &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="次构造函数"><a href="#次构造函数" class="headerlink" title="次构造函数"></a>次构造函数</h3><p>有主就有次，对应主构造函数的是次构造函数，我们可以多个构造函数来<strong>配置不同的参数组合</strong>。</p>
<p>使用<code>constructor</code>定义次构造函数。</p>
<p>使用次构造函数，可以定义<strong>初始化代码逻辑</strong>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">val</span> player = Player(<span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-number">12</span>)<br>    println(player)<br>&#125;<br><span class="hljs-comment">// 定义类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Player</span></span>(<br>    <span class="hljs-keyword">var</span> name:String,<br>    <span class="hljs-keyword">var</span> age:<span class="hljs-built_in">Int</span>,<br>    <span class="hljs-keyword">var</span> sNormal:<span class="hljs-built_in">Boolean</span><br>)&#123;<br>    <span class="hljs-comment">//只提供一个参数的构造函数</span><br>    <span class="hljs-comment">//多余的手动给初始值</span><br>    <span class="hljs-keyword">constructor</span>(name: String, age: <span class="hljs-built_in">Int</span>) : <span class="hljs-keyword">this</span>(name, age, <span class="hljs-literal">false</span>)&#123;<br>        <span class="hljs-keyword">this</span>.name = name.toUpperCase()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>定义构造函数时，可以给构造函数指定默认值，如果用户调用不提供值参，使用默认值。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">val</span> player = Player(<span class="hljs-string">&quot;Jack&quot;</span>, isNormal = <span class="hljs-literal">false</span>)<br>    println(player)<br>&#125;<br><br><span class="hljs-comment">// 定义类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Player</span></span>(<br>    _name:String,<br>    <span class="hljs-keyword">var</span> age:<span class="hljs-built_in">Int</span> = <span class="hljs-number">20</span>,<br>    <span class="hljs-keyword">var</span> isNormal:<span class="hljs-built_in">Boolean</span><br>)&#123;<br>    <span class="hljs-keyword">var</span> name = _name<br>    <span class="hljs-comment">//只提供一个参数的构造函数</span><br>    <span class="hljs-comment">//多余的手动给初始值</span><br>    <span class="hljs-keyword">constructor</span>(name: String, age: <span class="hljs-built_in">Int</span>) : <span class="hljs-keyword">this</span>(name, age, <span class="hljs-literal">false</span>)&#123;<br>        <span class="hljs-keyword">this</span>.name = name.uppercase()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-初始化"><a href="#3-初始化" class="headerlink" title="3 初始化"></a>3 初始化</h2><h3 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h3><p>初始化块可以设置变量或值，以及执行有效性检查，如检查传给某构造函数的值是否有效，<strong>初始化块代码会在构造类实例时执行。</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">init</span> &#123;<br>    require(age &gt; <span class="hljs-number">0</span>)&#123;<span class="hljs-string">&quot;age must be positive&quot;</span>&#125;<br>    require(name.isNotBlank())&#123;<span class="hljs-string">&quot;player must have a name.&quot;</span>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h3><ol>
<li>主构造函数里声明的属性。</li>
<li>类级别的属性赋值。</li>
<li><code>init</code>初始化块里的属性赋值和函数调用。</li>
<li>次级构造函数里的属性赋值和函数调用。</li>
</ol>
<h3 id="延迟初始化"><a href="#延迟初始化" class="headerlink" title="延迟初始化"></a>延迟初始化</h3><p>使用<code>lateinit</code>关键字相当于做了一个约定：在用它之前负责初始化</p>
<p>只要无法确认<code>lateinit</code>变量是否完成初始化，可以执行<code>isInitialized</code>检查</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Player</span></span>&#123;<br>    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> equipment:String<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">ready</span><span class="hljs-params">()</span></span>&#123;<br>        equipment = <span class="hljs-string">&quot;sharp knife&quot;</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">battle</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">// 判断是否初始化了</span><br>        <span class="hljs-keyword">if</span> (::equipment.isInitialized)<br>            println(equipment)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="惰性初始化"><a href="#惰性初始化" class="headerlink" title="惰性初始化"></a>惰性初始化</h3><p>延迟初始化并不是推后初始化的唯一方式，你也可以暂时不初始化某个变量，知道首次使用它，这个叫惰性初始化。</p>
<p><code>by lazy&#123; &#125;</code> 类似懒加载。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">val</span> p = Player(<span class="hljs-string">&quot;Jack&quot;</span>)<br>    Thread.sleep(<span class="hljs-number">3000</span>)<br>    println(p.config)<br>&#125;<br><span class="hljs-comment">// 定义类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Player</span></span>(_name: String)&#123;<br>    <span class="hljs-keyword">val</span> name = _name<br>    <span class="hljs-comment">// 惰性初始化，调用的时候再初始化</span><br>    <span class="hljs-keyword">val</span> config <span class="hljs-keyword">by</span> lazy &#123; loadConfig() &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadConfig</span><span class="hljs-params">()</span></span>:String&#123;<br>        println(<span class="hljs-string">&quot;loading...&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;xxx&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>kotlin 编译顺序为从上到下，与java不同，不能在第一行使用，第二行以后定义。</p>
<p>属性定义顺序也为从上到下。</p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>对象（单例）</title>
    <url>/2022/01/12/kotlin-study-day9/</url>
    <content><![CDATA[<p>对象与数据类等</p>
<span id="more"></span>

<h2 id="1-对象"><a href="#1-对象" class="headerlink" title="1 对象"></a>1 对象</h2><h3 id="object关键字"><a href="#object关键字" class="headerlink" title="object关键字"></a>object关键字</h3><p>使用object关键字，你可以定义一个<strong>只能产生一个实例的类</strong> - <strong>单例</strong>。</p>
<p>使用object关键字有三种方式：</p>
<ul>
<li>对象声明</li>
<li>对象表达式</li>
<li>伴生对象</li>
</ul>
<h3 id="对象声明"><a href="#对象声明" class="headerlink" title="对象声明"></a>对象声明</h3><ul>
<li>对象声明有利于组织代码和管理状态，尤其是管理整个应用运行生命周期内的某些一致性状态，而且节省资源。</li>
<li>通过object声明的类，可以直接使用类名调用方法。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 既是类名，又是实例名</span><br>    ApplicationConfig.doSomeThing()<br>&#125;<br><br><span class="hljs-keyword">object</span> ApplicationConfig&#123;<br>    <span class="hljs-keyword">init</span> &#123;<br>        println(<span class="hljs-string">&quot;ApplicationConfig loading....&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doSomeThing</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;doSomething&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="对象表达式"><a href="#对象表达式" class="headerlink" title="对象表达式"></a>对象表达式</h3><p>有时你不一定非要定义一个新的命名类不可，也许你需要某个现有类的一种变体实例，但<strong>只需用一次就行了</strong>，事实上，对于这种用完就丢的类实例，连命名都可以省了。</p>
<p>这个对象表达式是XX的子类，这个匿名类依然遵循object关键字的一个规则，即一旦实例化，该匿名类只能有唯一一个实例存在。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Player</span></span>&#123;<br>    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">load</span><span class="hljs-params">()</span></span> = <span class="hljs-string">&quot;loading nothing...&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 相当于继承了Player，内部重写load</span><br>    <span class="hljs-keyword">val</span> p = <span class="hljs-keyword">object</span> : Player()&#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">load</span><span class="hljs-params">()</span></span> = <span class="hljs-string">&quot;anonymous nothing...&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h3><p>如果你想将某个对象的初始化和一个类实例捆绑在一起，可以考虑使用伴生对象，使用<code>companion</code>修饰符，你可以在一个类定义里声明一个伴生对象，<strong>一个类只能有一个伴生对象</strong>。</p>
<p>伴生对象的初始化是在相应的类被加载（解析）时，也就是示例的 <code>ConfigMap</code> 被加载时。</p>
<p>伴生对象的成员可以直接使用类名来调用。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConfigMap</span></span>&#123;<br>    <span class="hljs-comment">// 只有调用load函数，或者实例化ConfigMap，companion object 才会实例化</span><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> PATH = <span class="hljs-string">&quot;sfdfdfdf&quot;</span><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">load</span><span class="hljs-params">()</span></span> = File(PATH).readBytes()<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ConfigMap.load()<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="对象初始化差别"><a href="#对象初始化差别" class="headerlink" title="对象初始化差别"></a>对象初始化差别</h3><ul>
<li>对象表达式是在使用他们的地方<strong>立即</strong>执行（及初始化）的；</li>
<li>对象声明是在第一次被访问到时<strong>延迟</strong>初始化的；</li>
<li>伴生对象的初始化是在相应的类被加载（解析）时，与 Java 静态初始化器的语义相匹配。</li>
</ul>
<h2 id="2-类"><a href="#2-类" class="headerlink" title="2 类"></a>2 类</h2><h3 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h3><p>如果一个类只对另一个类有用，那么将其嵌入到该类中并使这两个类保持在一起时合乎逻辑的，可以使用嵌套类。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    Player.Equipment(<span class="hljs-string">&quot;knife&quot;</span>).show()<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Player</span></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Equipment</span></span>(<span class="hljs-keyword">var</span> name: String)&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;equipment: <span class="hljs-variable">$name</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h3><p>用来专门存储数据的类，用<code>data class</code>关键字定义</p>
<p>数据类提供了<code>toString</code>的个性化实现</p>
<p><code>==</code>符号默认情况下，比较对象就是比较它们的引用值，数据类提供了<code>equals</code>和<code>hashCode</code>的个性化实现，所以可以看作是内容比较。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 自动生成toString方法</span><br>    println(Coordinate(<span class="hljs-number">34</span>,<span class="hljs-number">20</span>))<br>    <span class="hljs-comment">// 比较内容</span><br>    println(Coordinate(<span class="hljs-number">34</span>,<span class="hljs-number">20</span>) == Coordinate(<span class="hljs-number">34</span>,<span class="hljs-number">20</span>))<br>&#125;<br><br><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Coordinate</span></span>(<span class="hljs-keyword">var</span> x: <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">var</span> y: <span class="hljs-built_in">Int</span>)&#123;<br>    <span class="hljs-keyword">val</span> isInBounds = x &gt; <span class="hljs-number">0</span> &amp;&amp; y &gt; <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="copy函数"><a href="#copy函数" class="headerlink" title="copy函数"></a>copy函数</h4><p>除了重写Any类的部分函数，提供更好的默认实现外，数据类还提供了一个函数，它可以<strong>用来方便的复制一个对象</strong>。</p>
<p>假设你想创建一个student实例，除了name属性，它拥有和另一个先用student实例完全一样的属性值，如果student是个数据类，那么只需要调用copy函数，给想修改的属性传入值参就可以了。</p>
<p><strong>注意：</strong>copy 只会复制主构造函数传入的内容。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> s = Student(<span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-number">30</span>)<br>    s.subject = <span class="hljs-string">&quot;english&quot;</span><br>    <span class="hljs-comment">// age内容会被复制，subject不会</span><br>    <span class="hljs-keyword">val</span> copy = s.copy(<span class="hljs-string">&quot;Rose&quot;</span>)<br>    println(s)<br>    println(copy)<br>&#125;<br><br><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>(<span class="hljs-keyword">var</span> name: String, <span class="hljs-keyword">val</span> age: <span class="hljs-built_in">Int</span>)&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> hobby = <span class="hljs-string">&quot;music&quot;</span><br>    <span class="hljs-keyword">var</span> subject: String = <span class="hljs-string">&quot;math&quot;</span><br>    <span class="hljs-keyword">constructor</span>(_name: String) : <span class="hljs-keyword">this</span>(_name, <span class="hljs-number">10</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="解构声明"><a href="#解构声明" class="headerlink" title="解构声明"></a>解构声明</h4><p>解构声明的后台实现就是声明component1、component2等若干个组件函数，让每个函数负责管理你想返回的一个属性数据，如果你定义一个数据类，<strong>它会自动为所有定义在主构造函数的属性添加对应的Component函数</strong>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 解构语法，与list解构一致</span><br>    <span class="hljs-keyword">val</span> (x,y) = PlayScore(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>)<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PlayScore</span></span>(<span class="hljs-keyword">val</span> experince: <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">val</span> level: <span class="hljs-built_in">Int</span>)&#123;<br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">component1</span><span class="hljs-params">()</span></span> = experince<br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">component2</span><span class="hljs-params">()</span></span> = level<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>如果要将内置运算符应用在自定义类上，你必须重写运算符函数，告诉编译器如何操作自定义类。</p>
<p>常见操作符：</p>
<blockquote>
<p><code>+</code> ——-&gt; <code>plus</code></p>
<p><code>+=</code> ——-&gt; <code>plusAssign</code></p>
<p><code>==</code> ——-&gt; <code>equals</code></p>
<p><code>&gt;</code> ——-&gt; <code>compareTo</code></p>
<p><code>[]</code> ——-&gt; <code>get</code>    返回集合中指定位置的元素</p>
<p><code>..</code> ——-&gt; <code>rangeTo</code> 创建一个range对象</p>
<p><code>in</code> ——-&gt; <code>contains</code></p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> c1 = Coordinate(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)<br>    <span class="hljs-keyword">val</span> c2 = Coordinate(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)<br>    println(c1 + c2)<br>&#125;<br><br><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Coordinate</span></span>(<span class="hljs-keyword">var</span> x: <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">var</span> y: <span class="hljs-built_in">Int</span>)&#123;<br>    <span class="hljs-keyword">val</span> isInBounds = x &gt; <span class="hljs-number">0</span> &amp;&amp; y &gt; <span class="hljs-number">0</span><br>    <span class="hljs-comment">// 重写+运算符</span><br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">plus</span><span class="hljs-params">(other: <span class="hljs-type">Coordinate</span>)</span></span> = Coordinate(x + other.x, y + other.y)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><p>用来定义常量集合的一种特殊类</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Direction</span></span>&#123;<br>    EAST,<br>    WEST,<br>    SOUTH,<br>    NORTH<br>&#125;<br></code></pre></td></tr></table></figure>

<p>枚举类也可以定义函数</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(Direction.EAST.updateCoodinate(Coordinate(<span class="hljs-number">4</span>,<span class="hljs-number">4</span>)))<br>&#125;<br><br><span class="hljs-comment">// 枚举类</span><br><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Direction</span></span>(<span class="hljs-keyword">val</span> coordinate: Coordinate)&#123;<br>    EAST(Coordinate(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)),<br>    WEST(Coordinate(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)),<br>    SOUTH(Coordinate(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>)),<br>    NORTH(Coordinate(<span class="hljs-number">7</span>,<span class="hljs-number">8</span>));<br>    <br>    <span class="hljs-comment">// 更新坐标属性</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateCoodinate</span><span class="hljs-params">(playerCoordinate: <span class="hljs-type">Coordinate</span>)</span></span> = Coordinate(playerCoordinate.x + coordinate.x, playerCoordinate.y + coordinate.y)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="代数数据类型（ADT）"><a href="#代数数据类型（ADT）" class="headerlink" title="代数数据类型（ADT）"></a>代数数据类型（ADT）</h3><p>可以用来表示一组子类型的闭集。枚举就是一种简单的ADT。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    Driver(LicenseStatus.LEARNING).checkLicense()<br>&#125;<br><br><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LicenseStatus</span></span>&#123;<br>    UNQUALIFIED,<br>    LEARNING,<br>    QUALIFIED;<br>&#125;<br><br><span class="hljs-comment">// 检查驾驶证例子</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Driver</span></span>(<span class="hljs-keyword">var</span> status: LicenseStatus)&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">checkLicense</span><span class="hljs-params">()</span></span>: String&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span>(status)&#123;<br>            LicenseStatus.UNQUALIFIED -&gt; <span class="hljs-string">&quot;没资格&quot;</span><br>            LicenseStatus.LEARNING -&gt; <span class="hljs-string">&quot;在学&quot;</span><br>            LicenseStatus.QUALIFIED -&gt; <span class="hljs-string">&quot;有资格&quot;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h3><p>对于更复杂的ADT，你可以使用Kotlin的密封类（sealed class）来实现更复杂的定义，密封类可以用来定义一个类似于枚举类的ADT，但你可以更灵活的控制某个子类型。</p>
<p>密封类可以有若干个字类，要继承密封类，<strong>这些字类必须和它定义在同一个文件里</strong>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> status = LicenseStatus.QUALIFIED(<span class="hljs-string">&quot;12333&quot;</span>)<br>    <span class="hljs-keyword">val</span> driver = Driver(status)<br>    println(driver.checkLicense())<br>&#125;<br><br><span class="hljs-comment">//密封类</span><br><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LicenseStatus</span></span>&#123;<br>    <span class="hljs-keyword">object</span> UNQUALIFIED: LicenseStatus()<br>    <span class="hljs-keyword">object</span> LEARNING: LicenseStatus()<br>    <span class="hljs-comment">// 有驾驶证，传入驾驶证号</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QUALIFIED</span></span>(<span class="hljs-keyword">val</span> licenseId: String) : LicenseStatus()<br>&#125;<br><br><span class="hljs-comment">// 检查驾驶证例子</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Driver</span></span>(<span class="hljs-keyword">var</span> status: LicenseStatus)&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">checkLicense</span><span class="hljs-params">()</span></span>: String&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span>(status)&#123;<br>            <span class="hljs-keyword">is</span> LicenseStatus.UNQUALIFIED -&gt; <span class="hljs-string">&quot;没资格&quot;</span><br>            <span class="hljs-keyword">is</span> LicenseStatus.LEARNING -&gt; <span class="hljs-string">&quot;在学&quot;</span><br>            <span class="hljs-keyword">is</span> LicenseStatus.QUALIFIED -&gt; <span class="hljs-string">&quot;有资格，驾驶证编号：<span class="hljs-subst">$&#123;(status as LicenseStatus.QUALIFIED).licenseId&#125;</span>&quot;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>类的继承</title>
    <url>/2022/01/11/kotlin-study-day8/</url>
    <content><![CDATA[<p>类的继承与转换</p>
<span id="more"></span>

<h2 id="1-继承与类型转换"><a href="#1-继承与类型转换" class="headerlink" title="1 继承与类型转换"></a>1 继承与类型转换</h2><h3 id="继承与函数重载"><a href="#继承与函数重载" class="headerlink" title="继承与函数重载"></a>继承与函数重载</h3><p>类默认都是封闭的，如果需要让某个类可以被继承，必须使用<code>open</code>关键字修饰它。</p>
<p>使用 <code>:</code> 继承父类</p>
<p>重写父类方法也需要添加<code>open</code>关键字，子类使用<code>override</code>修饰。</p>
<p>覆盖方法总是使用与基类型方法相同的默认参数值。 当覆盖一个带有默认参数值的方法时，必须从签名中<strong>省略默认参数值</strong>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">(i: <span class="hljs-type">Int</span> = <span class="hljs-number">10</span>)</span></span> &#123;  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> : <span class="hljs-type">A</span></span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">(i: <span class="hljs-type">Int</span>)</span></span> &#123;  &#125;  <span class="hljs-comment">// 不能有默认值</span><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//父类</span><br><span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span></span>(<span class="hljs-keyword">val</span> name: String) &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">discription</span><span class="hljs-params">()</span></span> = <span class="hljs-string">&quot;Product: <span class="hljs-variable">$name</span>&quot;</span><br>    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">load</span><span class="hljs-params">()</span></span> = <span class="hljs-string">&quot;Nothing..&quot;</span><br>&#125;<br><span class="hljs-comment">//子类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LuxuryProduct</span> : <span class="hljs-type">Product</span></span>(<span class="hljs-string">&quot;Luxury&quot;</span>)&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">load</span><span class="hljs-params">()</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.load()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="类型检测与转换"><a href="#类型检测与转换" class="headerlink" title="类型检测与转换"></a>类型检测与转换</h3><p>Kotlin的<code>is</code>运算符是个不错的工具，可以用来检查某个对象的类型。使用<code>as</code>转换到某类型.</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">val</span> p = LuxuryProduct()<br>  	 <span class="hljs-comment">//检测类类型</span><br>        println(p <span class="hljs-keyword">is</span> Product)<br>        println(p <span class="hljs-keyword">is</span> File)<br>        <br>        <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">is</span> LuxuryProduct)&#123;<br>            <span class="hljs-comment">//类型转换调用子类方法</span><br>            println((p <span class="hljs-keyword">as</span> LuxuryProduct).special())<br>        &#125;<br>&#125;<br><span class="hljs-comment">//父类</span><br><span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span></span>(<span class="hljs-keyword">val</span> name: String) &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">discription</span><span class="hljs-params">()</span></span> = <span class="hljs-string">&quot;Product: <span class="hljs-variable">$name</span>&quot;</span><br>    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">load</span><span class="hljs-params">()</span></span> = <span class="hljs-string">&quot;Nothing..&quot;</span><br>&#125;<br><span class="hljs-comment">//子类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LuxuryProduct</span> : <span class="hljs-type">Product</span></span>(<span class="hljs-string">&quot;Luxury&quot;</span>)&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">special</span><span class="hljs-params">()</span></span> = <span class="hljs-string">&quot;LuxuryProduct special function&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="智能类型转换"><a href="#智能类型转换" class="headerlink" title="智能类型转换"></a>智能类型转换</h3><p>Kotlin编译器很聪明，只要能确定any is 父类条件检查属实，它就会将any当作子类类型对待，因此，编译器允许你不经类型转换直接使用。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> p = LuxuryProduct()<br>    <span class="hljs-comment">//类型转换</span><br>    println((p <span class="hljs-keyword">as</span> LuxuryProduct).special())<br>    <span class="hljs-comment">//上面转换过，这里不用再转换</span><br>    println(p.special())<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Any超类"><a href="#Any超类" class="headerlink" title="Any超类"></a>Any超类</h3><p>无须在代码里显示指定，每一个类都会继承一个共同的叫做 <code>Any</code> 的超类。</p>
<blockquote>
<p>Any里面有hasCode、toString等方法，但实现类不可见（具体平台有具体实现），如我们平时需要的<code>bean.toString()</code>，会打印出一串字符，此时可以重写toString()。</p>
</blockquote>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
</search>
